<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Task try</title>
  
  <subtitle>建立博客的第五天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ccgofa.top/"/>
  <updated>2019-05-11T13:39:05.806Z</updated>
  <id>https://www.ccgofa.top/</id>
  
  <author>
    <name>摇井</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>J2EE基础知识回回顾</title>
    <link href="https://www.ccgofa.top/2019/05/11/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <id>https://www.ccgofa.top/2019/05/11/J2EE基础知识回顾/</id>
    <published>2019-05-11T07:29:44.000Z</published>
    <updated>2019-05-11T13:39:05.806Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#servlet总结" target="_blank" rel="noopener">Servlet总结</a></li><li>阐述Servlet和CGI的区别?<ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#cgi的不足之处" target="_blank" rel="noopener">CGI的不足之处:</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#servlet的优点" target="_blank" rel="noopener">Servlet的优点：</a></li></ul></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#servlet接口中有哪些方法及servlet生命周期探秘" target="_blank" rel="noopener">Servlet接口中有哪些方法及Servlet生命周期探秘</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#get和post请求的区别" target="_blank" rel="noopener">get和post请求的区别</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#什么情况下调用doget和dopost" target="_blank" rel="noopener">什么情况下调用doGet()和doPost()</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#转发forward和重定向redirect的区别" target="_blank" rel="noopener">转发（Forward）和重定向（Redirect）的区别</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#自动刷新refresh" target="_blank" rel="noopener">自动刷新(Refresh)</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#servlet与线程安全" target="_blank" rel="noopener">Servlet与线程安全</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#jsp和servlet是什么关系" target="_blank" rel="noopener">JSP和Servlet是什么关系</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#jsp工作原理" target="_blank" rel="noopener">JSP工作原理</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#jsp有哪些内置对象、作用分别是什么" target="_blank" rel="noopener">JSP有哪些内置对象、作用分别是什么</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#request对象的主要方法有哪些" target="_blank" rel="noopener">Request对象的主要方法有哪些</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#requestgetattribute和-requestgetparameter有何区别" target="_blank" rel="noopener">request.getAttribute()和 request.getParameter()有何区别</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#include指令include的行为的区别" target="_blank" rel="noopener">include指令include的行为的区别</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#jsp九大内置对象，七大动作，三大指令" target="_blank" rel="noopener">JSP九大内置对象，七大动作，三大指令</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#讲解jsp中的四种作用域" target="_blank" rel="noopener">讲解JSP中的四种作用域</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#如何实现jsp或servlet的单线程模式" target="_blank" rel="noopener">如何实现JSP或Servlet的单线程模式</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#实现会话跟踪的技术有哪些" target="_blank" rel="noopener">实现会话跟踪的技术有哪些</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#cookie和session的的区别" target="_blank" rel="noopener">Cookie和Session的的区别</a></li></ul><h2 id="Servlet总结"><a href="#Servlet总结" class="headerlink" title="Servlet总结"></a>Servlet总结</h2><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>,在<strong>doGet()</strong>,<strong>doPost()中做相应的处理，并将回应HttpServletResponse</strong>反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用<strong>init()方法</strong>，销毁时调用<strong>destroy()方法</strong>。<strong>Servlet需要在web.xml中配置</strong>（MyEclipse中创建Servlet会自动配置），<strong>一个Servlet可以设置多个URL访问</strong>。<strong>Servlet不是线程安全</strong>，因此要谨慎使用类变量。</p><h2 id="阐述Servlet和CGI的区别"><a href="#阐述Servlet和CGI的区别" class="headerlink" title="阐述Servlet和CGI的区别?"></a>阐述Servlet和CGI的区别?</h2><h3 id="CGI的不足之处"><a href="#CGI的不足之处" class="headerlink" title="CGI的不足之处:"></a>CGI的不足之处:</h3><p>1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。</p><p>2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销</p><p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p><h3 id="Servlet的优点"><a href="#Servlet的优点" class="headerlink" title="Servlet的优点:"></a>Servlet的优点:</h3><p>1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</p><p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p><p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p><p>4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p><p>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p><p>参考：《javaweb整合开发王者归来》P7</p><h2 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h2><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p><ul><li><strong>void init(ServletConfig config) throws ServletException</strong></li><li><strong>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</strong></li><li><strong>void destory()</strong></li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()</li></ul><p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><p>参考：《javaweb整合开发王者归来》P81</p><h2 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h2><blockquote><p>网上也有文章说：get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">https://www.cnblogs.com/logsharing/p/8448446.html</a>，知乎对应的问题链接：<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">get和post区别？</a>）！我下面给出的只是一种常见的答案。</p></blockquote><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p><p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p><p>③get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；</p><p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p><p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p><p>补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。</p><p>还有另外一种回答。推荐大家看一下：</p><ul><li><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">https://www.zhihu.com/question/28586791</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</a></li></ul><h2 id="什么情况下调用doGet-和doPost"><a href="#什么情况下调用doGet-和doPost" class="headerlink" title="什么情况下调用doGet()和doPost()"></a>什么情况下调用doGet()和doPost()</h2><p>Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。</p><h2 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forward）</strong> 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response);</span><br></pre></td></tr></table></figure><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong></li></ol><p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><ol><li><strong>从数据共享来说</strong></li></ol><p>forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</p><ol><li><strong>从运用地方来说</strong></li></ol><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p><ol><li>从效率来说</li></ol><p>forward:高. redirect:低.</p><h2 id="自动刷新-Refresh"><a href="#自动刷新-Refresh" class="headerlink" title="自动刷新(Refresh)"></a>自动刷新(Refresh)</h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.setHeader(&quot;Refresh&quot;,&quot;5;URL=http://localhost:8080/servlet/example.htm&quot;);</span><br></pre></td></tr></table></figure><p>其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次）</p><h2 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a>Servlet与线程安全</h2><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。 注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><p>参考：《javaweb整合开发王者归来》P92</p><h2 id="JSP和Servlet是什么关系"><a href="#JSP和Servlet是什么关系" class="headerlink" title="JSP和Servlet是什么关系"></a>JSP和Servlet是什么关系</h2><p>其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p><h2 id="JSP工作原理"><a href="#JSP工作原理" class="headerlink" title="JSP工作原理"></a>JSP工作原理</h2><p>JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。 工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。 .class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。 <a href="https://camo.githubusercontent.com/081bbba45674c21b2a6c2de3eb20f008622f8752/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f332f33312f313632376265653037333037396132383f773d36373526683d32393226663d6a70656726733d313333353533" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/081bbba45674c21b2a6c2de3eb20f008622f8752/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f332f33312f313632376265653037333037396132383f773d36373526683d32393226663d6a70656726733d313333353533" alt="JSP工作原理"></a> 由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。</p><p>开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。</p><p>参考：《javaweb整合开发王者归来》P97</p><h2 id="JSP有哪些内置对象、作用分别是什么"><a href="#JSP有哪些内置对象、作用分别是什么" class="headerlink" title="JSP有哪些内置对象、作用分别是什么"></a>JSP有哪些内置对象、作用分别是什么</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP内置对象 - CSDN博客</a></p><p>JSP有9个内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h2 id="Request对象的主要方法有哪些"><a href="#Request对象的主要方法有哪些" class="headerlink" title="Request对象的主要方法有哪些"></a>Request对象的主要方法有哪些</h2><ul><li>setAttribute(String name,Object)：设置名字为name的request 的参数值</li><li>getAttribute(String name)：返回由name指定的属性值</li><li>getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例</li><li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组</li><li>getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度</li><li>getHeader(String name) ：获得HTTP协议定义的文件头信息</li><li>getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例</li><li>getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例</li><li>getInputStream() ：返回请求的输入流，用于获得请求中的数据</li><li>getMethod() ：获得客户端向服务器端传送数据的方法</li><li>getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值</li><li>getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li><li>getParameterValues(String name)：获得有name指定的参数的所有值</li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li><li>getQueryString() ：获得查询字符串</li><li>getRequestURI() ：获取发出请求字符串的客户端地址</li><li>getRemoteAddr()：获取客户端的 IP 地址</li><li>getRemoteHost() ：获取客户端的名字</li><li>getSession([Boolean create]) ：返回和请求相关 Session</li><li>getServerName() ：获取服务器的名字</li><li>getServletPath()：获取客户端所请求的脚本文件的路径</li><li>getServerPort()：获取服务器的端口号</li><li>removeAttribute(String name)：删除请求中的一个属性</li></ul><h2 id="request-getAttribute-和-request-getParameter-有何区别"><a href="#request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和 request.getParameter()有何区别"></a>request.getAttribute()和 request.getParameter()有何区别</h2><p><strong>从获取方向来看：</strong></p><p>getParameter()是获取 POST/GET 传递的参数值；</p><p>getAttribute()是获取对象容器中的数据值；</p><p><strong>从用途来看：</strong></p><p>getParameter用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p><p>getAttribute用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了 mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p><p>另外，可以用 setAttribute,getAttribute 发送接收对象.而 getParameter 显然只能传字符串。 setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p><p><strong>总结：</strong></p><p>getParameter 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p><p>getAttribute 返回的是Object，需进行转换,可用setAttribute 设置成任意对象，使用很灵活，可随时用</p><h2 id="include指令include的行为的区别"><a href="#include指令include的行为的区别" class="headerlink" title="include指令include的行为的区别"></a>include指令include的行为的区别</h2><p><strong>include指令：</strong> JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下： &lt;%@ include file=”文件相对 url 地址” %&gt;</p><p>i<strong>nclude动作：</strong> jsp:include动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下： &lt;jsp:include page=”相对 URL 地址” flush=”true” /&gt;</p><h2 id="JSP九大内置对象，七大动作，三大指令"><a href="#JSP九大内置对象，七大动作，三大指令" class="headerlink" title="JSP九大内置对象，七大动作，三大指令"></a>JSP九大内置对象，七大动作，三大指令</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP九大内置对象，七大动作，三大指令总结</a></p><h2 id="讲解JSP中的四种作用域"><a href="#讲解JSP中的四种作用域" class="headerlink" title="讲解JSP中的四种作用域"></a>讲解JSP中的四种作用域</h2><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><ul><li><strong>page</strong>代表与一个页面相关的对象和属性。</li><li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li><li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h2 id="如何实现JSP或Servlet的单线程模式"><a href="#如何实现JSP或Servlet的单线程模式" class="headerlink" title="如何实现JSP或Servlet的单线程模式"></a>如何实现JSP或Servlet的单线程模式</h2><p>对于JSP页面，可以通过page指令进行设置。 &lt;%@page isThreadSafe=”false”%&gt;</p><p>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p><p>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p><h2 id="实现会话跟踪的技术有哪些"><a href="#实现会话跟踪的技术有哪些" class="headerlink" title="实现会话跟踪的技术有哪些"></a>实现会话跟踪的技术有哪些</h2><ol><li><strong>使用Cookie</strong></li></ol><p>向客户端发送Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie c =<span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"value"</span>); <span class="comment">//创建Cookie </span></span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); <span class="comment">//设置最大时效，此处设置的最大时效为一天</span></span><br><span class="line">response.addCookie(c); <span class="comment">//把Cookie放入到HTTP响应中</span></span><br></pre></td></tr></table></figure><p>从客户端读取Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String name =<span class="string">"name"</span>; </span><br><span class="line">Cookie[]cookies =request.getCookies(); </span><br><span class="line"><span class="keyword">if</span>(cookies !=<span class="keyword">null</span>)&#123; </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;cookies.length;i++)&#123; </span><br><span class="line">    Cookie cookie =cookies[i]; </span><br><span class="line">    <span class="keyword">if</span>(name.equals(cookis.getName())) </span><br><span class="line">    <span class="comment">//something is here. </span></span><br><span class="line">    <span class="comment">//you can get the value </span></span><br><span class="line">    cookie.getValue(); </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value</p><p><strong>缺点:</strong> 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p><ol><li>URL 重写</li></ol><p>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</p><p><strong>优点：</strong> 在Cookie被禁用的时候依然可以使用</p><p><strong>缺点：</strong> 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。</p><p>3.隐藏的表单域</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"hidden"</span> name =<span class="string">"session"</span> value=<span class="string">"..."</span>/&gt;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong> Cookie被禁时可以使用</p><p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p><ol><li>HttpSession</li></ol><p>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p><h2 id="Cookie和Session的的区别"><a href="#Cookie和Session的的区别" class="headerlink" title="Cookie和Session的的区别"></a>Cookie和Session的的区别</h2><ol><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/J2EE基础知识.md#servlet总结&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Servle
      
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="web" scheme="https://www.ccgofa.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>java多线程（二）</title>
    <link href="https://www.ccgofa.top/2019/05/10/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.ccgofa.top/2019/05/10/Java网络编程/</id>
    <published>2019-05-10T08:52:38.000Z</published>
    <updated>2019-05-10T14:02:48.818Z</updated>
    
    <content type="html"><![CDATA[<p>最近在重新整理我之前做过的一个web服务器项目，设计到的主要是TCP的Java编程，然后今天做一个笔试题有一些其他Java网络编程的知识，很蒙，今晚学习了一下基本使用</p><a id="more"></a><ul><li>InetAddress获取主机的IP地址等信息</li><li>URL，统一资源定位符。通过这个可以打开一个输入流和获取一个连接，从流里面可以获取资源</li><li>URLEncoder进行编码，URKLDecoder进行解码</li><li>ServertSocket，这个这里就没有案例了，因为我比较了解。</li><li>UDP的 DatagramPacket（包装一条信息）和 DatagramSocket（发送/接受 一条信息）</li></ul><h2 id="1、InetAddress"><a href="#1、InetAddress" class="headerlink" title="1、InetAddress"></a>1、InetAddress</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InetAddress主要用于IP地址，有两个子类Inet4Address Inet6Address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取本机InetAddress</span></span><br><span class="line">        InetAddress locAdd=InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">//根据名称获取InetAddress</span></span><br><span class="line">        InetAddress baidu=InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">        InetAddress.getByAddress(locAdd.getAddress());   <span class="comment">//需要一个字节数组</span></span><br><span class="line">        <span class="comment">//获取一些信息</span></span><br><span class="line">        System.out.println(<span class="string">"本机主机地址为："</span>+locAdd.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">"百度主机地址为："</span>+baidu.getHostAddress());</span><br><span class="line">        <span class="comment">//getAddress方法和getHostAddress类似，它们的唯一区别是getHostAddress方法返回的是字符串形式的IP地址，</span></span><br><span class="line">        <span class="comment">// 而getAddress方法返回的是byte数组形式的IP地址。</span></span><br><span class="line">        System.out.println(<span class="string">"本机是地址： "</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] address = locAdd.getAddress();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : address) &#123;</span><br><span class="line">            System.out.print(b&gt;<span class="number">0</span>?b:<span class="number">256</span>+b);   <span class="comment">//注意这里的转换</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"本机是否可连接："</span>+locAdd.isReachable(<span class="number">5000</span>));</span><br><span class="line">        System.out.println(<span class="string">"百度时候可达："</span> + baidu.isReachable(<span class="number">5000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、URL"><a href="#2、URL" class="headerlink" title="2、URL"></a>2、URL</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * URL：统一资源定位符，通过这个可以准确的找到一个网页</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法有两种，根据String的地址 或者 主机+端口+uri</span></span><br><span class="line">        URL url=<span class="keyword">new</span> URL(<span class="string">"https://www.cnblogs.com/yulinfeng/p/5844151.html"</span>);</span><br><span class="line"></span><br><span class="line">        URLConnection urlConnection = url.openConnection(); <span class="comment">//打开一个连接</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"内容的大小："</span>+urlConnection.getContentLength());</span><br><span class="line">        System.out.println(<span class="string">"内容类型"</span>+urlConnection.getContentType());</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = url.openStream();            <span class="comment">//获取一个输入流</span></span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">"H:\\java\\idea-workspace\\jvm\\src\\com\\test.html"</span>);</span><br><span class="line">        BufferedWriter bufferedWriter=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file,<span class="keyword">true</span>));<span class="comment">//可设置追加</span></span><br><span class="line"></span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(inputStream);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            bufferedWriter.write(scanner.next());</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、编码解码"><a href="#3、编码解码" class="headerlink" title="3、编码解码"></a>3、编码解码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * URL的编码和解码操作：URLEncoder进行编码，URKLDecoder进行解码</span></span><br><span class="line"><span class="comment"> * 这个也是比较常用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLCoderDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">       String file=<span class="string">"中文"</span>;</span><br><span class="line">       String gb2312 = URLEncoder.encode(file, <span class="string">"utf-8"</span>);  <span class="comment">//编码</span></span><br><span class="line">       String comeBack= URLDecoder.decode(file,<span class="string">"utf-8"</span>);  <span class="comment">//解码</span></span><br><span class="line">       System.out.println(file);</span><br><span class="line">       System.out.println(gb2312);</span><br><span class="line">       System.out.println(comeBack);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、UDP实现简单客户端和服务端"><a href="#4、UDP实现简单客户端和服务端" class="headerlink" title="4、UDP实现简单客户端和服务端"></a>4、UDP实现简单客户端和服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP的socket变成，我有做过一个web服务器，相对比较熟悉、</span></span><br><span class="line"><span class="comment"> * 直接UDP,</span></span><br><span class="line"><span class="comment"> * DatagramPacket（包装一条信息）和DatagramSocket（发送/接受 一条信息）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        <span class="comment">//DatagramPacket提供两个构造方法</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1204</span>];</span><br><span class="line">        DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(bytes,<span class="number">1204</span>);  <span class="comment">//还可以添加主机地址 和 端口号</span></span><br><span class="line">        DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"等待接受消息"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            String message=<span class="keyword">new</span> String(packet.getData(),</span><br><span class="line">                    <span class="number">0</span>,packet.getLength());  <span class="comment">//数据包可以获取数据 和 数据长度</span></span><br><span class="line">            System.out.println(<span class="string">"from:"</span>+packet.getAddress()+<span class="string">": "</span>+packet.getPort());</span><br><span class="line">            System.out.println(<span class="string">"收到信息"</span>);</span><br><span class="line">            System.out.println(message);</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">"wo ai ni "</span>.getBytes();</span><br><span class="line">        <span class="comment">//客户端需要地址，和端口</span></span><br><span class="line">        DatagramPacket datagramPacket=<span class="keyword">new</span> DatagramPacket</span><br><span class="line">                (bytes,bytes.length, InetAddress.getByName(<span class="string">"localhost"</span>),<span class="number">6666</span>);</span><br><span class="line">        DatagramSocket datagramSocket=<span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>); <span class="comment">//客户端端口</span></span><br><span class="line">        <span class="comment">//socket可以接和发，客户端发，服务端收</span></span><br><span class="line">        <span class="comment">//结合</span></span><br><span class="line">        System.out.println(<span class="string">"发送 udp ----"</span>);</span><br><span class="line">        datagramSocket.send(datagramPacket);</span><br><span class="line">        System.out.println(<span class="string">"发送 完毕===="</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在重新整理我之前做过的一个web服务器项目，设计到的主要是TCP的Java编程，然后今天做一个笔试题有一些其他Java网络编程的知识，很蒙，今晚学习了一下基本使用&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="学习" scheme="https://www.ccgofa.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="网络" scheme="https://www.ccgofa.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Manacher和KMP</title>
    <link href="https://www.ccgofa.top/2019/05/09/Manacher%E5%92%8CKMP/"/>
    <id>https://www.ccgofa.top/2019/05/09/Manacher和KMP/</id>
    <published>2019-05-09T05:22:07.000Z</published>
    <updated>2019-05-09T11:17:48.700Z</updated>
    
    <content type="html"><![CDATA[<p>Manacher和KMP实现</p><a id="more"></a><h2 id="Manacher和KMP"><a href="#Manacher和KMP" class="headerlink" title="Manacher和KMP"></a>Manacher和KMP</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * Manacher</span></span><br><span class="line"><span class="comment"> * 1、help数组，用来记录每个位置的最长回文长度</span></span><br><span class="line"><span class="comment"> * 2、R，记录最右边界</span></span><br><span class="line"><span class="comment"> * 3、C,记录最右边界的中心</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：一、如果当前位置不被R包裹，直接进行暴力求回文。并跟新C和R</span></span><br><span class="line"><span class="comment"> *       二、如果当前位置被R包裹</span></span><br><span class="line"><span class="comment"> *          1、当前位置以C为中心的对称点，的回文长度没有突破R回文边界，当前位置回文就等于对称位置的回文长度</span></span><br><span class="line"><span class="comment"> *          2、当前位置以C为中心的对称点，的回文长度突破了R回文边界，当前位置回文就等于R-i</span></span><br><span class="line"><span class="comment"> *          3、恰好踩在了R位置，直接以半径为len去暴力求新的len。跟新C和R。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Marnach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">difStrlen</span><span class="params">(String str)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">char</span>[] ss=str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] index=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>, i=<span class="number">0</span>;i&lt;ss.length;i++)&#123;</span><br><span class="line">            j=Math.max(j, index[ss[i]]);</span><br><span class="line">            len=Math.max(len, i-j+<span class="number">1</span>);</span><br><span class="line">            index[ss[i]]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMlen</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c=<span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            c[a++]=str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(i!=str.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                c[a++]=<span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> R =-<span class="number">1</span>;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">int</span> C=<span class="number">0</span>;<span class="comment">//回文中心</span></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] help=<span class="keyword">new</span> <span class="keyword">int</span>[c.length];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len; <span class="comment">//记录当前当前位置的回文长度</span></span><br><span class="line">        <span class="keyword">while</span>(R&lt;c.length &amp;&amp; i&lt;c.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(R==c.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;R)&#123;</span><br><span class="line">               len = postLen(c,i,<span class="number">1</span>);</span><br><span class="line">               help[i]=len;</span><br><span class="line">               C=i;</span><br><span class="line">               R=i+len-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                len=help[<span class="number">2</span>*C-i];</span><br><span class="line">                <span class="keyword">if</span>(len+(i-C)&lt;help[C])&#123;</span><br><span class="line">                    help[i]=help[<span class="number">2</span>*C-i];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len+(i-C)&gt;help[C])&#123;</span><br><span class="line">                    help[i]=help[C]-(i-C);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        len=postLen(c, i, len);</span><br><span class="line">                        help[i]=len;</span><br><span class="line">                        C=i;</span><br><span class="line">                        R=i+len-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max=Math.max(max, help[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">postLen</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i-len&gt;-<span class="number">1</span> &amp;&amp; i+len&lt;c.length &amp;&amp; c[i-len]==c[i+len])&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(findMlen(<span class="string">"aasdbbbbbbdsaa"</span>));</span><br><span class="line">        System.out.println(difStrlen(<span class="string">"stradad"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KmpTest</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KmpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c1=str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] c2=str2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next =findMinlen(str2);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;c1.length &amp;&amp; j&lt;c2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c1[i]==c2[j])&#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(next[j]==-<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j==c2.length?c1.length-c2.length:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findMinlen(String str)&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c=str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next=<span class="keyword">new</span> <span class="keyword">int</span>[str.length()+<span class="number">1</span>];</span><br><span class="line">        next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=str.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i-<span class="number">1</span>]==c[cn])&#123;</span><br><span class="line">                next[i++]=++cn;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cn&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                cn=next[cn];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                next[i++]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(str+str.substring(next[i-<span class="number">1</span>], str.length()));</span><br><span class="line">         <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        findMinlen(<span class="string">"adad"</span>);</span><br><span class="line">        System.out.println(kmp(<span class="string">"str1"</span>, <span class="string">"r1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Manacher和KMP实现&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccgofa.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.ccgofa.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁和事务</title>
    <link href="https://www.ccgofa.top/2019/05/07/MySQL%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
    <id>https://www.ccgofa.top/2019/05/07/MySQL锁和事务/</id>
    <published>2019-05-07T10:46:35.000Z</published>
    <updated>2019-05-07T10:49:39.067Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL一些高级知识点也复习了一下啦</p><a id="more"></a><p>回顾一些知识点：</p><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><p>构成单一逻辑工作单元的操作集合称作事务。例如淘宝买东西，从你账户中扣款到淘宝账户，这就是一个事务，涉及两个读写操作。要么都成功，要么都不成功。<br>事务具有4大特性：ACID</p><ul><li>原子性（atomicity）：事务所有操作在数据库中要么全部正确反应，要么完全不反应。</li><li>一致性（consistency）：隔离执行事务时，保持数据库前后数据的一致性。这是事务程序员的责任。</li><li>隔离性（isolation）：尽管多个事务并发执行，系统也得确保其中一个事务正常执行而不被来自并发执行的数据库语句干扰。</li><li>持久性（durability）：事务完成后，对数据库的改变必须是永久的，即使系统出现故障。</li></ul><h2 id="二、事务隔离级别"><a href="#二、事务隔离级别" class="headerlink" title="二、事务隔离级别"></a>二、事务隔离级别</h2><p>为了保证多个事务对同一个表访问的并发执行，MySQL提供了四个事务隔离性级别，事务调用策略将根据隔离级别配置实现不同的事务执行调度尽量保证并发性。级别从低到高依次是</p><ul><li>未提交读（read uncommitted）：就是一个事务可以读取另一个未提交事务的数据（脏读问题）</li><li>已提交的读（read committed）：就是一个事务要等另一个事务提交后才能读取数据。（不可重复读问题）</li><li>可重复读（repeatabl read）：就是在某个事务开始读取数据（事务开启）时，另外事务不再允许修改（update数据）操作。（幻读问题）</li><li>可串行化（serializable）：保证事务的以串行化顺序执行。效率最低的一种事务执行方式，导致事务没有并发的可能性。</li></ul><p>MySQL的每一条单一的SQL语句都是期望着具有原子性的，也就是一句SQL语句的执行是不会被打断的，但涉及到并发的访问与表资源的共享，会出现一些问题，底部需要有一种锁的机制来维持这种原子性。具体到不同的引擎实现的机制是不一样的，对<strong>于Innodb的实现默认是使用的行锁，达到可重复度的隔离级别。</strong></p><hr><p>来看看锁    </p><h2 id="一、表锁"><a href="#一、表锁" class="headerlink" title="一、表锁"></a>一、表锁</h2><p>表锁是<strong>MyISAM</strong>的默认锁，它是偏读的锁，建锁的成本低，锁的颗粒度大，并发度低，尤其是写锁，并发度极低。</p><p>怎么用：</p><ul><li>首先你要使你的表的引擎是MyISAM</li><li>show open tables 或者 show table status可以查看表的上锁情况</li><li>lock table  youtable read(write)上锁。</li><li>unlock tables 解锁</li></ul><p><strong>read锁：自己可读不可改，别人可读改阻塞</strong>（共享锁）</p><p><strong>write锁：自己可读也可改，别人读写都阻塞</strong>（独占锁）</p><p>表锁不是研究的重点，和事务的第四个隔离级别有关，事务时InnoDB支持的，所以重点看看行锁。</p><h2 id="二、行锁"><a href="#二、行锁" class="headerlink" title="二、行锁"></a>二、行锁</h2><p>行锁时InnoDB的实现事务的锁。它时偏写的锁，建锁的成本也较高，但是锁的颗粒度时最小的，并发度也是最高的。</p><h4 id="怎么用："><a href="#怎么用：" class="headerlink" title="怎么用："></a>怎么用：</h4><ul><li>在一个事务操作里，有update性质或者声明了update的操作，那么这行就会被上锁。</li></ul><p>前面说过在一个单一的SQL语句里其实就是一个事务，或者说是一个原子操作，并且每次执行都会自动commit。我们稍微设置一下：<strong>set autocommit=0</strong>，那么我们就每条sql语句都需要手动提交，变成了一个个事务了。</p><h4 id="行锁有什么特点："><a href="#行锁有什么特点：" class="headerlink" title="行锁有什么特点："></a>行锁有什么特点：</h4><ul><li>读的可见性：A改的A能马上看见，B需要A和B都提交了才能开得到变化===这不就是<strong>可重复读</strong></li><li>写的原则性：A改某一行，B也去<strong>改同一行阻塞，改其他行不阻塞</strong></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1557222717814.png" alt="1557222717814"></p><h4 id="行锁和事务的隔离级别："><a href="#行锁和事务的隔离级别：" class="headerlink" title="行锁和事务的隔离级别："></a>行锁和事务的隔离级别：</h4><p>都说MySQL的默认隔离级别时可重复读，那么你会发现可重复的要求刚刚时行锁提供的，要求双方都提交才能看到对方的改变，当时因为时行锁，有别人可能会插入数据，提交之后再读可能会多处数据，这就是幻读。</p><p>那么<strong>读已提交</strong>和<strong>读未提交</strong>是怎么回事呢</p><ul><li>读未提交：这个好说，啥也不干，事务修改数据之后直接写如主表（有点像JMM主内存），其他事务读取就会看到变化，那么就出现脏读。</li><li>读已提交：读已提交有点像改的内容先放在工作内存，只有当commit的时候才会写入主表，别的事务就能读到改变。这样事务前后读的就不一样的，出现了不可重复读的wenti。</li></ul><h4 id="行锁的一一些问题"><a href="#行锁的一一些问题" class="headerlink" title="行锁的一一些问题"></a>行锁的一一些问题</h4><ul><li>测试发现，锁行的条件（where语句后面的条件），一定要上索引，没有索引直接变表锁</li><li>如果where条件使得索引失效，比如varchar类型没加双引号作为了查询条件，使用了like模糊，组成索引没有符合最左前缀索引失效，都是会使得<strong>行锁变表锁</strong></li><li>结合上面两点：<strong>行锁的锁定是依赖索引的</strong></li><li>还有一点是<strong>间隙锁</strong>：就是当锁定的行是一个范围的时候，再这个范围里面插入也是会阻塞的</li></ul><p>总结一下：其实天下并发一个样，既要高并发，又要高可用，为了能安全的用必须要个锁，锁马马虎虎可以全部锁上，这样必然影响并发性，阻塞增加。我们要做的是有一个合理的锁的力度，表锁到行锁的变化和Java中的Hashtable到ConcurrentHashMap的思想是一致的，锁的颗粒度减小必然操作也是更复杂的，我们再高效又高用的道路上一直前进。</p><hr><p>最后补上MySQL主从复制</p><h2 id="三、MySQL-主从复制原理"><a href="#三、MySQL-主从复制原理" class="headerlink" title="三、MySQL 主从复制原理"></a>三、MySQL 主从复制原理</h2><p>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:</p><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3616190683,3608800796&amp;fm=173&amp;app=49&amp;f=JPEG?w=640&amp;h=251&amp;s=01704730B3307423404091CA030070B3" alt="img"></p><p>l 主节点 binary log dump 线程</p><p>当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</p><p>l 从节点I/O线程</p><p>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。</p><p>l 从节点SQL线程</p><p>SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p><p>总的流程是，主写dump，主dump io 到从relay，从机读取执行sql。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL一些高级知识点也复习了一下啦&lt;/p&gt;
    
    </summary>
    
      <category term="DB" scheme="https://www.ccgofa.top/categories/DB/"/>
    
    
      <category term="数据库" scheme="https://www.ccgofa.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程工具类（一）</title>
    <link href="https://www.ccgofa.top/2019/05/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://www.ccgofa.top/2019/05/05/多线程工具类/</id>
    <published>2019-05-05T14:56:41.000Z</published>
    <updated>2019-05-05T12:02:53.475Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个线程要在其他线程全部结束后在结束的n种方法。。。。</span></span><br><span class="line"><span class="comment"> * 1、sleep，可以估算的情况下可以，最垃圾的办法</span></span><br><span class="line"><span class="comment"> * 2、join,将其他线程一个个的join进来，还凑合，但是麻烦</span></span><br><span class="line"><span class="comment"> * 3、while(Thread.activeCount()&gt;2)  yeild。这个在平时测试还是很不错的一个办法。2表示main线程和gc线程。</span></span><br><span class="line"><span class="comment"> * 4、CountDownLacthTest，并发工具。</span></span><br><span class="line"><span class="comment"> * 5、CyclicBarrier，同步屏障。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLacthTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c=<span class="keyword">new</span> CountDownLatch(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger integer=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">100</span> ; j++) &#123;</span><br><span class="line">                    integer.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;, <span class="string">"i"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        c.await();</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CycliBarrier，也是设置一个初始值，每个线程调用 await方法。</span></span><br><span class="line"><span class="comment"> * 当await调用的次数达到了初始值，所有等待线程释放。</span></span><br><span class="line"><span class="comment"> * 此外CycliBarrierh还有一些其他功能，比如当都到达屏障可以设置一个先要去执行的方法。</span></span><br><span class="line"><span class="comment"> * 还可以reset(),重置计数器，让线程重新执行一次。</span></span><br><span class="line"><span class="comment"> * 还有一些其他的有用的方法，isBroken，getNumberwaiting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycliBarrierTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>, <span class="keyword">this</span>);</span><br><span class="line">    ConcurrentHashMap&lt;String,Integer&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(),Integer.valueOf(finalI));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AtomicInteger result= <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        map.forEach((k,v) -&gt; &#123;</span><br><span class="line">            result.addAndGet(v);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt;  entry :map.entrySet())&#123;</span><br><span class="line">            s+=entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result+<span class="string">" "</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CycliBarrierTest cycliBarrierTest=<span class="keyword">new</span> CycliBarrierTest();</span><br><span class="line">        cycliBarrierTest.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.ccgofa.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习" scheme="https://www.ccgofa.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL高级知识</title>
    <link href="https://www.ccgofa.top/2019/05/04/MySQL%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.ccgofa.top/2019/05/04/MySQL高级知识/</id>
    <published>2019-05-04T12:02:20.000Z</published>
    <updated>2019-05-05T11:27:53.943Z</updated>
    
    <content type="html"><![CDATA[<p>开始学习一些数据库的高级知识，以及复习之前学过的知识</p><a id="more"></a><p><strong>MySQL内部架构</strong></p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1556971494404&amp;di=d29bee346947141e1b166bf6710971b5&amp;imgtype=0&amp;src=http%3A%2F%2Fimage20.it168.com%2F201611_670x502%2F2701%2F39b96aa41090f9bb.png" alt></p><ul><li>连接层：连接业务</li><li>服务层：sql分析，sql优化</li><li>引擎层：各种引擎，可以选择使用</li><li>存储层：与底层设备打交道</li></ul><h3 id="InnoDB和MyISAM-区别："><a href="#InnoDB和MyISAM-区别：" class="headerlink" title="InnoDB和MyISAM 区别："></a>InnoDB和MyISAM 区别：</h3><p>\1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；  </p><p>\2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；  </p><p>\3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p><p>\4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；  </p><p>\5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；   </p><p> <strong>InnoDB：事务、行锁、外键、聚集索引、不支持全文，</strong></p><h1 id="sql语句优化："><a href="#sql语句优化：" class="headerlink" title="sql语句优化："></a>sql语句优化：</h1><h3 id="一、join："><a href="#一、join：" class="headerlink" title="一、join："></a>一、join：</h3><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4057843062,2771292381&amp;fm=15&amp;gp=0.jpg" alt></p><p>记住这个图的前五个，后面的可以直接用union。union可以去重。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6:左连接加有链接就是了</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u <span class="keyword">right</span> <span class="keyword">join</span> t <span class="keyword">on</span> u.t_id=t.id</span><br><span class="line">   -&gt; <span class="keyword">union</span></span><br><span class="line">   -&gt; <span class="keyword">select</span> * <span class="keyword">from</span> u <span class="keyword">left</span> <span class="keyword">join</span> t <span class="keyword">on</span> u.t_id=t.id;</span><br><span class="line"></span><br><span class="line">7:4+5就得到了7</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u <span class="keyword">right</span> <span class="keyword">join</span> t <span class="keyword">on</span> u.t_id=t.id <span class="keyword">where</span> u.t_id <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line">   -&gt; <span class="keyword">union</span></span><br><span class="line">   -&gt; <span class="keyword">select</span> * <span class="keyword">from</span> u <span class="keyword">left</span> <span class="keyword">join</span> t <span class="keyword">on</span> u.t_id=t.id <span class="keyword">where</span> t.id <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="二、索引：索引（index）是MySQL高效查询的数据结构"><a href="#二、索引：索引（index）是MySQL高效查询的数据结构" class="headerlink" title="二、索引：索引（index）是MySQL高效查询的数据结构"></a>二、索引：索引（index）是MySQL高效查询的数据结构</h3><p><strong>索引的两大功能：查找和排序。where和order的影响</strong></p><p>1、什么时候需要建立索引：</p><ul><li>主键自动建自增的不为空的唯一索引</li><li>需要频繁查询的列建立索引</li><li>需要排序分组的建立索引</li><li>外键</li></ul><p>2、什么时候不需要建立索引</p><ul><li>数据量比较小</li><li>需要频繁修改的</li><li>字段重复性高的，比如性别、国籍</li></ul><p>索引基础信息我已经再 &gt;&gt;MySQL索引里面记录，这里不再重复。</p><h3 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h3><p>性能分析主要有三步骤</p><p>1、分析MySQL自动优化结果，optirniz，一般我们都是用MySQL默认的，所以这部分罢了</p><p>2、机器性能查开：top,free,iostat,vmstat。查看机器性能</p><p>3、explian分析sql语句</p><ul><li>id：分析sql执行的顺序，id相同从上往下，id不同id大的优先</li><li>select-type：sql语句的类型，有simple，primaty, subquery（子查询）,Derived,union</li><li><p>type（重要）：查询类型，<strong>一般来说，得保证查询至少达到range级别，最好能达到ref。</strong></p><ul><li>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</li></ul></li><li><p>table:查询的表</p></li><li><p>possible_keys 和 key：可能用到的索引和实际用到的索引，也是很重要的指标</p></li><li><p>key_len：</p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好。</p></li><li><p>ref：显示索引的那一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值。</p></li><li>row：得到结构大致估计需要扫描的行数，自然越小越好，也是很重要的指标</li><li>Extra：包含不适合在其他列中显式但十分重要的额外信息<ul><li>using filesort，文件内部发生了排序，没用用到索引（九死一生）</li><li>using temporary，使用了历史表保存了中间结果，常见于排序order by和分组查询group by。（十死无生）</li><li>usring index，使用到了索引，覆盖索引。</li></ul></li></ul><h3 id="四、索引优化"><a href="#四、索引优化" class="headerlink" title="四、索引优化"></a>四、索引优化</h3><p><strong>索引建立</strong></p><ul><li>单表：为查询字段建立索引，并且避免索引失效</li><li>双表：为连接进来的表建立索引，因为原表反正都要查看</li><li>三表同样，应该让jion进来的表加索引</li></ul><p>join用小表驱动大表，就是让大表jion进来，给大表加索引。让被驱动的字段加上索引</p><p><strong>索引失效：</strong></p><ul><li>复合索引，要遵循最左前缀原则，带头大哥不能没，中间兄弟不能断</li><li>复合索引中间兄弟不能有范围查询，会让后面的失去索引</li><li>索引的条件不能有任何计算</li><li>不等于，与&gt;&lt; 查找都会丢失索引。</li><li>like： %x%   和%x  有索引失效，x%不会。<ul><li><strong>如何让%x%，有索引，这里只能用上覆盖索引，就是给某些列加上复合索引，查询的时候只查其中的列，就可以不用去表里查过，可以用上using index。从type 从 all变成index</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始学习一些数据库的高级知识，以及复习之前学过的知识&lt;/p&gt;
    
    </summary>
    
      <category term="DB" scheme="https://www.ccgofa.top/categories/DB/"/>
    
    
      <category term="数据库" scheme="https://www.ccgofa.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://www.ccgofa.top/2019/05/04/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>https://www.ccgofa.top/2019/05/04/MySQL索引/</id>
    <published>2019-05-04T05:22:07.000Z</published>
    <updated>2019-05-04T12:05:13.874Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL索引摘抄</p><a id="more"></a><p>mysql的索引分为单列索引(主键索引,唯索引,普通索引)和组合索引.</p><p>单列索引:一个索引只包含一个列,一个表可以有多个单列索引.</p><p>组合索引:一个组合索引包含两个或两个以上的列,</p><p><strong>(一)索引的创建</strong></p><p><strong>1.单列索引</strong></p><ul><li>1-1)    普通索引,这个是最基本的索引,</li></ul><p>其sql格式是 CREATE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length)) 或者 ALTER TABLE TableName ADD INDEX IndexName(<code>字段名</code>(length))</p><p><strong>第一种方式 :</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> account_Index <span class="keyword">ON</span> <span class="string">`award`</span>(<span class="string">`account`</span>);</span><br></pre></td></tr></table></figure><p><strong>第二种方式:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE award ADD INDEX account_Index(`account`)</span><br></pre></td></tr></table></figure><p> 如果是CHAR,VARCHAR,类型,length可以小于字段的实际长度,如果是BLOB和TEXT类型就必须指定长度,</p><ul><li>1-2)    唯一索引,与普通索引类似,但是不同的是唯一索引要求所有的类的值是唯一的,这一点和主键索引一样.但是他允许有空值,</li></ul><p>其sql格式是 CREATE UNIQUE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length)); 或者 ALTER TABLE TableName ADD UNIQUE (column_list)  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> account_UNIQUE_Index <span class="keyword">ON</span> <span class="string">`award`</span>(<span class="string">`account`</span>);</span><br></pre></td></tr></table></figure><ul><li>1-3)    主键索引,不允许有空值,(在B+TREE中的InnoDB引擎中,主键索引起到了至关重要的地位)</li></ul><p>主键索引建立的规则是 int优于varchar,一般在建表的时候创建,最好是与表的其他字段不相关的列或者是业务不相关的列.一般会设为 int 而且是 AUTO_INCREMENT自增类型的，</p><p><strong>2.组合索引</strong></p><p>一个表中含有多个单列索引不代表是组合索引,通俗一点讲 组合索引是:包含多个字段但是只有索引名称</p><p>其sql格式是 CREATE INDEX IndexName On <code>TableName</code>(<code>字段名</code>(length),<code>字段名</code>(length),…);</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> nickname_account_createdTime_Index <span class="keyword">ON</span> <span class="string">`award`</span>(<span class="string">`nickname`</span>, <span class="string">`account`</span>, <span class="string">`created_time`</span>);</span><br></pre></td></tr></table></figure><p><strong>在使用查询的时候遵循mysql组合索引的”最左前缀”,下面我们来分析一下 什么是最左前缀</strong>：及索引where时的条件要按照建立索引的时候字段的排序方式，切不支持范围索引。</p><p><strong>3、全文索引</strong></p><p>文本字段上(text)如果建立的是普通索引,那么只有对文本的字段内容前面的字符进行索引,其字符大小根据索引建立索引时申明的大小来规定.</p><p>如果文本中出现多个一样的字符,而且需要查找的话,那么其条件只能是 where column like  ‘%xxxx%’ 这样做会让索引失效</p><p>.这个时候全文索引就起到了作用了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> FULLTEXT(column1, column2)</span><br></pre></td></tr></table></figure><p>有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablename</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(column1, column2) AGAINST(‘xxx′, ‘sss′, ‘ddd′)</span><br></pre></td></tr></table></figure><p>这条命令将把column1和column2字段里有xxx、sss和ddd的数据记录全部查询出来。</p><p><strong>(二)索引的删除</strong></p><p>删除索引的mysql格式 :DORP INDEX IndexName ON <code>TableName</code></p><p><strong>(三)使用索引的优点</strong></p><p>1.可以通过建立唯一索引或者主键索引,保证数据库表中每一行数据的唯一性.<br>2.建立索引可以大大提高检索的数据,以及减少表的检索行数<br>3.在表连接的连接条件 可以加速表与表直接的相连<br>4.在分组和排序字句进行数据检索,可以减少查询时间中 分组 和 排序时所消耗的时间(数据库的记录会重新排序)<br>5.建立索引,在查询中使用索引 可以提高性能</p><p><strong>(四)使用索引的缺点</strong></p><p>1.在创建索引和维护索引 会耗费时间,随着数据量的增加而增加<br>2.索引文件会占用物理空间,除了数据表需要占用物理空间之外,每一个索引还会占用一定的物理空间<br>3.当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL索引摘抄&lt;/p&gt;
    
    </summary>
    
      <category term="DB" scheme="https://www.ccgofa.top/categories/DB/"/>
    
    
      <category term="数据库" scheme="https://www.ccgofa.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="https://www.ccgofa.top/2019/04/30/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>https://www.ccgofa.top/2019/04/30/个人简历/</id>
    <published>2019-04-30T12:33:48.000Z</published>
    <updated>2019-04-30T12:38:57.021Z</updated>
    
    <content type="html"><![CDATA[<p>这是一份个人简历。。</p><a id="more"></a><h2 id="联系方式-期望职位：Java开发实习生"><a href="#联系方式-期望职位：Java开发实习生" class="headerlink" title="联系方式 | 期望职位：Java开发实习生"></a>联系方式 | <font face="微软雅黑" size="2" color="#0099ff">期望职位：<u>Java开发实习生</u></font></h2><ul><li>手机（微信号）：173-9651-0930</li><li>Email：<a href="mailto:cwellshake@gmail.com" target="_blank" rel="noopener">cwellshake@gmail.com</a> </li></ul><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息 |"></a>个人信息 |</h2><ul><li>陈发荣 / 男 / 1998</li><li>教育背景：福州大学（211）</li><li>技术博客：<a href="http://cfr321.github.io" target="_blank" rel="noopener">http://cfr321.github.io</a></li><li>Github：<a href="https://github.com/cfr321" target="_blank" rel="noopener">https://github.com/cfr321</a></li><li>证书技能：CTE4 / 自学C语言、数据结构和算法、计算机网络知识等计算机专业知识</li></ul><h2 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单 |"></a>技能清单 |</h2><ul><li>熟悉Java基础，了解常见设计模式</li><li>熟悉Servlet、JSP、JDBC等JavaWeb基础知识</li><li>熟悉IntelliJ IDEA、eclipse、vscode、Git、Maven等工具</li><li>熟悉MySQL关系型数据库，了解Redis</li><li>熟悉SringMVC、Spring、Mybatis框架技术；了解SpringBoot、SpringData</li><li>了解HTML+CSS+JS，以及BootStrap、Vue.js等前端知识</li><li>了解Linux常用命令，能够搭建开发环境</li></ul><h2 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目 |"></a>个人项目 |</h2><ul><li><p><strong>员工管理系统</strong></p><p>项目介绍：这是一个独立完成的员工管理系统，通过这个项目使我更加熟悉了SSM框架，以及学习BootStrap对页面的搭建，项目主要采用页面发送ajax到后端，实现对员工的信息的修改。整个项目业务并不复杂，但第一次做项目还是出现了很多问题，比如bootstrap的cs效果引入问题、MySQL8.0版本连接问题等等，我是完全自学的、遇到了问题我只能不断地去网上搜索，翻阅很多别人的博客，最终让问题得到解决。</p></li><li><p><strong>CkServer服务器</strong></p><p>一个类似tomcat的web服务器，这是在我学习Java网络编程时候做的一个小项目。它能接受HTTP请求以及响应，实现了war包的自动解压、xml的解析获取servlet、以及常见的状态码的响应。一开始它只支持IO流操作，一个请求一个线程；我又去学习了NIO的知识，并运用在这个小项目上。</p></li><li><p><strong>cako商城</strong></p><p>这是一个基于SpringBoot和SpringData的分布式项目，前端用的是vue.js，用nginx实现方向代理。目前并没有完全开发完全，现在在开发后台商品管理系统，从中我也在不断记取不断进步。</p></li></ul><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息 |"></a>其他信息 |</h2><ul><li>校园经历：曾担任idea精英汇新闻官部长，负责微信公众号管理，有公众号管理和推文撰写经验</li><li>性格特点：专注度高，热爱学习，富有创造力</li><li>个人爱好：运动、游戏、读书和敲代码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一份个人简历。。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://www.ccgofa.top/categories/life/"/>
    
    
      <category term="分享" scheme="https://www.ccgofa.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>线程池技术</title>
    <link href="https://www.ccgofa.top/2019/04/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.ccgofa.top/2019/04/29/线程池技术/</id>
    <published>2019-04-29T11:50:23.000Z</published>
    <updated>2019-04-29T07:47:22.928Z</updated>
    
    <content type="html"><![CDATA[<p>线程学到了线程池技术了，可能多线程学习也要告一段落了，回顾，线程我们实现多线程的方式已经有了四种，Thread继承，Runnable接口实现，Callable接口实现，和最后的线程池。</p><a id="more"></a><h2 id="一、Callable"><a href="#一、Callable" class="headerlink" title="一、Callable"></a>一、Callable</h2><p>以前并没有聊过这个东东，先说一下这个Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDome</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call== come in "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableDome());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  output:</span></span><br><span class="line"><span class="comment">     * call== come in </span></span><br><span class="line"><span class="comment">     * 2</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>对于上面这个代码有以下几点总结：</p><ul><li><p>Thread并没有为Callable提供构造方法，不能像Runnable一样直接传入，这时候就需要一个适配器 FutureTask，这个东西实现了Runnable接口，所以能被Thread接受，其次FutureTask 提供了传入 Callable接口的构造方法。- - —–FutureTask在这里就是适配器，这就是典型的适配器模式。</p></li><li><p>其实这里还有一个策略模式，对于任何类，只要实现了Runnable接口，它就能被Thread接受，这就是策略模式</p></li><li>比较Callable和Runnable，前者的运行方法是call,不再是run，而且有了返回值。</li><li>最终的打印结果只有一个 <strong>call== come in</strong> ，这里也是要注意的，已经得出结果的线程操作不会去在运行一次，当然你要再弄个FutureTask，是能再运行的。</li></ul><h2 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h2><ul><li>一看类图关系：着重注意TreadPoolExecutor</li></ul><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1556533417437&amp;di=1ef2e2a983708dff311248fe2b7965e5&amp;imgtype=0&amp;src=http%3A%2F%2Fimg2.ph.126.net%2Fxw6HP23EPM_QC6NedtenXw%3D%3D%2F2857533963667137425.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、线程池：ThreadPoolExecutor</span></span><br><span class="line"><span class="comment"> * Java中有五种实现：</span></span><br><span class="line"><span class="comment"> * newFixedThreadPool       //一池规定线程数</span></span><br><span class="line"><span class="comment"> * newCachedThreadPool      //一池n线程数，</span></span><br><span class="line"><span class="comment"> * newSingleThreadExecutor  //一池一线程</span></span><br><span class="line"><span class="comment"> * newScheduledThreadPool   //延迟加载的</span></span><br><span class="line"><span class="comment"> * newWorkStealingPool      //根据系统cup确定核心线程数的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2、底层都是时去用ThreadPoolExecutor实现的：</span></span><br><span class="line"><span class="comment"> * ThreadPoolExecutord有七个属性：</span></span><br><span class="line"><span class="comment"> * ThreadPoolExecutor threadPool1=new ThreadPoolExecutor(</span></span><br><span class="line"><span class="comment"> *                 5,       //corepoolsize    核心线程数</span></span><br><span class="line"><span class="comment"> *                 8,       //maxmumpoolsize  最大线程数</span></span><br><span class="line"><span class="comment"> *                 1L,      //keepAliveTime   普通线程为被使用多久撤销</span></span><br><span class="line"><span class="comment"> *                 TimeUnit.SECONDS,  //TimeUnit时间单位</span></span><br><span class="line"><span class="comment"> *                 new LinkedBlockingQueue&lt;Runnable&gt;(5),  //阻塞队列的类型</span></span><br><span class="line"><span class="comment"> *                 Executors.defaultThreadFactory(),        //线程工厂，默认即可</span></span><br><span class="line"><span class="comment"> *                 new ThreadPoolExecutor.DiscardOldestPolicy());   //拒绝策略，当全都满了怎么处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3、拒绝策略：有四种</span></span><br><span class="line"><span class="comment"> * AbortPolicy          //抛异常</span></span><br><span class="line"><span class="comment"> * CallerRunsPolicy     //给调用线程池的线程去处理</span></span><br><span class="line"><span class="comment"> * DiscardOldestPolicy  //丢弃等待最久的线程</span></span><br><span class="line"><span class="comment"> * DiscardtPolicy       //直接丢弃要进来的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService threadPool= Executors.newWorkStealingPool();</span><br><span class="line">        ThreadPoolExecutor threadPool1=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">8</span>,<span class="number">1L</span>,TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">14</span> ; i++) &#123;</span><br><span class="line">                           <span class="keyword">int</span> finalI = i;</span><br><span class="line">                           threadPool.execute(()-&gt;&#123;</span><br><span class="line">                               System.out.println(Thread.currentThread().getName()+<span class="string">"\t "</span>+ finalI);</span><br><span class="line">                           &#125;);</span><br><span class="line">                       &#125;</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                   threadPool.shutdown();</span><br><span class="line">               &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二看具体属性关系</li></ul><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1556533349128&amp;di=f6bb7d3b935256d9d16e5cfc12ea2c4d&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2Fa4dc669d271fab4585886cdfe28934f2.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100" alt></p><ul><li>三看流程</li></ul><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1556533417432&amp;di=9a79f4150664a0ec141ce19b3a3945e3&amp;imgtype=0&amp;src=http%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_png%2FwXExy1PE3KNvpJXxqLASfibLlicOdemyyLWGdjXgXjn9YE8zaARJO1W2UNspVoxrHhWP8wvMWh8VPkdTkNSBXm6Q%2F640%3Fwx_fmt%3Dpng" alt></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>线程池主要要了解的就是 Java中提供的几种实现，线程池构造的七种属性，它们的关系以及操作的流程。</p><p>注意：实际生产中我们其实基本不用Java自带的那几种配好的线程池，因为拒绝策略不好，或者阻塞列队直接Integer.MAX也是不合适，还有线程数的设计也可能不符合要求。往往需要我们自己去配置。</p><p>关于配置线程池的线程数：</p><ul><li>cup密集型：电脑cup数加一。</li><li>io密集型：一般可以是电脑cup的八到十倍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程学到了线程池技术了，可能多线程学习也要告一段落了，回顾，线程我们实现多线程的方式已经有了四种，Thread继承，Runnable接口实现，Callable接口实现，和最后的线程池。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.ccgofa.top/categories/Java/"/>
    
    
      <category term="多线程" scheme="https://www.ccgofa.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池技术</title>
    <link href="https://www.ccgofa.top/2019/04/29/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8BTreeMap/"/>
    <id>https://www.ccgofa.top/2019/04/29/源码解读之TreeMap/</id>
    <published>2019-04-29T11:50:23.000Z</published>
    <updated>2019-05-02T05:45:04.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码解读之TreeMap"><a href="#源码解读之TreeMap" class="headerlink" title="源码解读之TreeMap"></a>源码解读之TreeMap</h1><p>首先我们要了解的 TreeMap底层是一个红黑树结构，搞搞懂TreeMap，TreeSet也就差不多了。</p><a id="more"></a><h2 id="一、那什么是红黑树"><a href="#一、那什么是红黑树" class="headerlink" title="一、那什么是红黑树"></a>一、那什么是红黑树</h2><ul><li>首先它是一个二叉查找树，它有二叉查找树的所有特性，（但它不是一颗平衡二叉树，它并不是完全平衡的！）</li></ul><p>额外的性质</p><ul><li>性质1. 节点是红色或黑色。</li><li>性质2. 根节点是黑色。</li><li>性质3. 每个叶节点（NIL节点，空节点）是黑色的。</li><li>性质4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul><p><strong>不能同时有两个红色，以及每个节点到它能到的叶子节点的黑节点数相同</strong></p><h2 id="二、什么是左旋什么是右旋"><a href="#二、什么是左旋什么是右旋" class="headerlink" title="二、什么是左旋什么是右旋"></a><strong>二、什么是左旋什么是右旋</strong></h2><p>之前我看的是Java版数据结构和算法分析里面的红黑树介绍，emmmmm可能当时水平不够，看的很晕，现在回过头去看源码，发现左旋右旋也没那么复杂，左旋右旋就是单一的操作，只要合理的组合，就能实现二叉树的平衡。</p><ul><li>右旋，讲parent放到左孩子的右边：<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1556767965889.png" alt="1556767965889"> </li></ul><p><strong>这个图片是右旋</strong></p><p>很好理解：</p><ul><li>就想着先断开，然后把parent结到 left的右边不不就行了</li><li>当然还有两个细节，就是<strong>left</strong>本来右边有东西的啊，所以要把left的右边连接到parent左边。啊？你问我为什么接到左边？因为parent左边本来是left，现在left跑上面去了，parent左边自然就空了。</li><li>最后就是把这个旋转好的树，接回整个大树，就是让left取代parent在整个树中的位置。</li></ul><h2 id="三、源码走起"><a href="#三、源码走起" class="headerlink" title="三、源码走起"></a>三、源码走起</h2><ul><li>继承关系</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>比较陌生的应该是NavigableMap，NavigableMap接口又继承于SortedMap，简单的来说这就是一个排序的Map，排序的就自然能提供找最大，找最小，按顺序迭代,这里就不仔细研究了。</p><p>推荐阅读：!(<a href="https://blog.csdn.net/u010126792/article/details/62236367" target="_blank" rel="noopener">https://blog.csdn.net/u010126792/article/details/62236367</a>)</p><ul><li>节点结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有左有右还有妈，分黑分白是一家</strong></p><ul><li>构造方法</li></ul><p>构造方法有普通构造、还可以传入一个Map，底层就自动帮你转成TreeMap，还可以传入比较器，因为这是Sorted的map。</p><ul><li>put方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">            root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 看看是有没有传入的比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);  <span class="comment">//重点在这里，调节二叉树</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法其实很简单嘛，就是普通的二叉查找树的插入收端。</p><ul><li><strong>fixAfterInsertion(e);</strong>  关键方法，调节红黑树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">        x.color = RED;</span><br><span class="line"><span class="comment">//parent已经是红色了才有必要调节</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">            <span class="comment">//一、parent是它自己parent的左孩子</span></span><br><span class="line">               <span class="comment">//         G</span></span><br><span class="line">               <span class="comment">//       /   \</span></span><br><span class="line">               <span class="comment">//     p       y</span></span><br><span class="line">               <span class="comment">//    / </span></span><br><span class="line">               <span class="comment">//   x </span></span><br><span class="line">            <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="comment">//看看兄弟节点是否也为红，同为红则可以向上，合二红为一红</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//看x是parent的左还是右孩子，来决定是要单旋还是双旋</span></span><br><span class="line">                    <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                        <span class="comment">//旋转之后x又变成了最下面的，</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//二、如果X的父节点（假设为:P）是其父节点的父节点（假设为:G）的右节点</span></span><br><span class="line">                <span class="comment">//                G</span></span><br><span class="line">                <span class="comment">//              /   \</span></span><br><span class="line">                <span class="comment">//             y     P</span></span><br><span class="line">                <span class="comment">//                    \</span></span><br><span class="line">                <span class="comment">//                     x</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="comment">//同样看看时候可以合二红为一红</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//同样看看是要但旋转还是双旋转</span></span><br><span class="line">                    <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>最后来看看旋转操作，下面是左旋的，右旋类似</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">           p.right = r.left;  <span class="comment">//不能忘了这一步，得让r的左边有人接手</span></span><br><span class="line">           <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">               r.left.parent = p;</span><br><span class="line">           r.parent = p.parent;</span><br><span class="line">           <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)<span class="comment">//这几个判断就是讲r去带原来p的位置</span></span><br><span class="line">               root = r;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">               p.parent.left = r;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               p.parent.right = r;</span><br><span class="line">           r.left = p;</span><br><span class="line">           p.parent = r;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>干脆把remove也读了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Delete node p, and then rebalance the tree.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       size--;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//如果有左也有右，就到右孩子里面找最左的s节点放大p位置，然后去删掉s</span></span><br><span class="line">       <span class="comment">//这个就是查找树删除的策略</span></span><br><span class="line">       <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">           p.key = s.key;</span><br><span class="line">           p.value = s.value;</span><br><span class="line">           p = s;</span><br><span class="line">       &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//到这里p一定是，要不有左没右，要么有右没左，要不都没有，</span></span><br><span class="line">       <span class="comment">//让replacement记录其中存在的孩子</span></span><br><span class="line">       Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果存在孩子，就让孩子与 p的parent连接删掉p</span></span><br><span class="line">           replacement.parent = p.parent;</span><br><span class="line">           <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">               root = replacement;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">               p.parent.left  = replacement;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">           p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 调节红黑树</span></span><br><span class="line">           <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(replacement);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// 自己就是根节点</span></span><br><span class="line">           root = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           <span class="comment">//没有孩子节点，就可以直接删掉了，不过依然要调节红黑树</span></span><br><span class="line">           <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(p);</span><br><span class="line"><span class="comment">//删除p节点</span></span><br><span class="line">           <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                   p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                   p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">               p.parent = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>删除操作的整体逻辑也不复杂，和二叉搜素树差不多，差异也是需要调节红黑树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断调节与否的关键就是看p是不是黑节点</span></span><br><span class="line"><span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">                fixAfterDeletion(replacement);</span><br></pre></td></tr></table></figure><ul><li>当然接下来看看fixAfterDeletion函数了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                <span class="comment">//        p</span></span><br><span class="line">               <span class="comment">//       /   \</span></span><br><span class="line">               <span class="comment">//     'x'    sib</span></span><br><span class="line">                </span><br><span class="line">                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"><span class="comment">//另一边是红的，把它变黑，然后p边红，旋转。</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//如果sib左右孩子都是黑的，直接让sib变红，左边黑数都减了，再去调节parentOf(x)</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//好复杂。。。。。总的来说就是让parent变成黑色，加入左边</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//这里是sib的右孩子已经是黑色了，左孩子是红色。</span></span><br><span class="line">                    <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                        setColor(leftOf(sib), BLACK);</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        rotateRight(sib);</span><br><span class="line">                        sib = rightOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将parent变黑，然后然sib与原来parent颜色相同，sib本来是黑色的，</span></span><br><span class="line">                    <span class="comment">//但sib的右孩子或者左孩子左一定有一个不是黑色了，如果是右孩子为红，好说，让它变黑</span></span><br><span class="line">                    <span class="comment">//取代sib，右边的黑树数量就不会改变。</span></span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 后面相似，就是x是右孩子，然后就去与左孩子比较就好</span></span><br><span class="line">                Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">。。。。。。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setColor(x, BLACK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一、如果P节点是黑色直接插入</p><p>二、如果P是红节点</p><ul><li>P是G的左孩子还是右孩子：<ul><li>G的另外一个孩子是也是红：向上，把两红变一红，然后去调节G节点</li><li>G的另外一个孩子不是红色：那就要旋转了<ul><li>如果三个 x, p  ,G成一条直线，但旋转G,让G变红，P变黑</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;源码解读之TreeMap&quot;&gt;&lt;a href=&quot;#源码解读之TreeMap&quot; class=&quot;headerlink&quot; title=&quot;源码解读之TreeMap&quot;&gt;&lt;/a&gt;源码解读之TreeMap&lt;/h1&gt;&lt;p&gt;首先我们要了解的 TreeMap底层是一个红黑树结构，搞搞懂TreeMap，TreeSet也就差不多了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.ccgofa.top/categories/Java/"/>
    
    
      <category term="多线程" scheme="https://www.ccgofa.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的阻塞队列</title>
    <link href="https://www.ccgofa.top/2019/04/28/Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://www.ccgofa.top/2019/04/28/Java中的阻塞队列/</id>
    <published>2019-04-28T06:06:53.000Z</published>
    <updated>2019-04-29T07:16:04.355Z</updated>
    
    <content type="html"><![CDATA[<p>阻塞列队也是Java高并发里面常用的工具类，今天学习了一下，总结 一下。</p><a id="more"></a><p>注意：该随笔内容完全引自<a href="http://wsmajunfeng.iteye.com/blog/1629354，写的很好，非常感谢，复制过来算是个积累，怕以后找不到。" target="_blank" rel="noopener">http://wsmajunfeng.iteye.com/blog/1629354，写的很好，非常感谢，复制过来算是个积累，怕以后找不到。</a></p><p>一. 前言</p><p>　　在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p><p>二. 认识BlockingQueue</p><p>　　阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：<br><img src="https://pic002.cnblogs.com/images/2010/161940/2010112414472791.jpg" alt="img"><br>　　从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p><p>　　常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种）</p><p>　　　　先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。</p><p>　　　　后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。　　</p><p>​      多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒），下面两幅图演示了BlockingQueue的两个常见阻塞场景：<em><img src="https://pic002.cnblogs.com/images/2010/161940/2010112414442194.jpg" alt="img">　　　　　　　<strong>如上图所示：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</strong><img src="https://pic002.cnblogs.com/images/2010/161940/2010112414451925.jpg" alt="img">　　　<strong>如上图所示：当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</strong></em></p><p>　　这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法：</p><p>三. <strong>BlockingQueue的核心方法</strong>：</p><p>　　1.放入数据</p><p>　　　　（1）offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法</p><p> 的线程）；　　　　　　<br>     　　（2）offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。</p><p>　　　　（3）put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.</p><p>　　2. 获取数据</p><p>　　　　（1）poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;</p><p>　　　　（2）poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间</p><p>超时还没有数据可取，返回失败。</p><p>　　　　（3）take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入; </p><p>　　　　（4）drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p><p>四. <strong>常见BlockingQueue</strong></p><p>　　在了解了BlockingQueue的基本功能后，让我们来看看BlockingQueue家庭大致有哪些成员？</p><p><img src="https://images0.cnblogs.com/blog2015/697611/201504/242030449842574.png" alt="img"></p><p>　　1. <strong>ArrayBlockingQueue</strong></p><p>　　基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p>　　ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><p>　　2.<strong>LinkedBlockingQueue</strong></p><p>　　基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p>　　作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p><p>　　ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p><p>　　下面的代码演示了如何使用BlockingQueue：</p><p>　　<strong>3. DelayQueue</strong></p><p>　　DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><p>　　使用场景：</p><p>　　DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p><p>　　<strong>4. PriorityBlockingQueue</strong></p><p>　　 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p><p>　　<strong>5. SynchronousQueue</strong></p><p>　　 一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p><p>　　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:</p><p>　　如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</p><p>　　但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p><p>五. 小结</p><p>　　BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多线间的自动等待于唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者消费者模式  3.0  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResouce</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingDeque=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResouce</span><span class="params">(BlockingQueue&lt;String&gt; blockingDeque)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingDeque = blockingDeque;</span><br><span class="line">        System.out.println(blockingDeque.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String Date=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> reValue;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            Date=atomicInteger.incrementAndGet()+<span class="string">""</span>;</span><br><span class="line">            reValue=blockingDeque.offer(Date,<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(reValue)&#123;</span><br><span class="line">                System.out.println(<span class="string">"生产成功"</span>+Date);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"生产失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"停止生产"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myComsu</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String result=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            result=blockingDeque.poll(<span class="number">2L</span>,TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="keyword">null</span> || result.equalsIgnoreCase(<span class="string">""</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">"没有取到"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"去到蛋糕"</span>+result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flag=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer_BlockQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyResouce myResouce=<span class="keyword">new</span> MyResouce(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始生产"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResouce.myProd();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"pro"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始消费"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResouce.myComsu();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"comsu"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>);&#125;<span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">        myResouce.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阻塞列队也是Java高并发里面常用的工具类，今天学习了一下，总结 一下。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.ccgofa.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="集合" scheme="https://www.ccgofa.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="https://www.ccgofa.top/2019/04/27/%E9%94%81/"/>
    <id>https://www.ccgofa.top/2019/04/27/锁/</id>
    <published>2019-04-27T04:23:48.000Z</published>
    <updated>2019-04-27T06:37:49.549Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>学习三部曲：理论+实践+总结</p><h3 id="一、公平锁和非公平锁"><a href="#一、公平锁和非公平锁" class="headerlink" title="一、公平锁和非公平锁"></a>一、公平锁和非公平锁</h3><p>公平锁符合先到先得，有先来后到之分；非公平锁就没有，都是同时竞争锁，而且趋于短作业优先。</p><p>ReentrantLock默认就是非公平锁，非公平锁有着更好的吞吐率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);  <span class="comment">//设置为公平锁</span></span><br></pre></td></tr></table></figure><p>synchronized，也是非公平锁</p><h3 id="二、可重入锁（递归锁）"><a href="#二、可重入锁（递归锁）" class="headerlink" title="二、可重入锁（递归锁）"></a>二、可重入锁（递归锁）</h3><p>ReentrantLock 和 Synchronized都是个可重入锁：</p><p>重入锁：同一个线程外层获取锁后，这个线程可以进入任何这把锁的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//case1:证明了synchronized是可重入锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法一被调用了"</span>);</span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法二被调用了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Doma01 doma01=<span class="keyword">new</span> Doma01();</span><br><span class="line">    doma01.method1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//case2：证明了ReentrantLock是可重入锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dome2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked  method1"</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked  method2"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码都能正常运行，线程可以访问到其他的同样锁的方法，可重入锁的目的是防止了死锁。自锁。</p><p>注意，ReenteankLock，加锁和解锁的次数一定要匹配，调用了几次lock（），就需要几unlock()，才能释放锁，其他线程才能获得到锁。</p><p><strong>少了unlock()，会出现锁未释放，程序阻塞。而多了unlock（）程序是会报错的。</strong></p><p>java.lang.IllegalMonitorStateException</p><h3 id="三、自旋锁"><a href="#三、自旋锁" class="headerlink" title="三、自旋锁"></a>三、自旋锁</h3><p>自旋：多次来看看时候能获得锁，看了不能获得就去干自己的，然后一段时间后又来看看时候能获得锁。</p><p>手写自旋锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpinLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置Thread的原子对象，对其修改具有原子性</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference=<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">"\t come in"</span>);</span><br><span class="line">        <span class="comment">//自旋的去看atomicReference是否为空了，为空就将自己设置进去。</span></span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>,thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">"\t come out"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋锁问题：当一个线程长时间占用资源，其他线程将会不断的去尝试获取锁，那么就会消耗cup性能。</p><h3 id="四、独占锁（写锁）-共享锁（读锁）-读写锁"><a href="#四、独占锁（写锁）-共享锁（读锁）-读写锁" class="headerlink" title="四、独占锁（写锁）/共享锁（读锁）/ 读写锁"></a>四、独占锁（写锁）/共享锁（读锁）/ 读写锁</h3><p>多线程操作资源，有时又需要读的时候可以共同访问，但是写的时候其他线程不能访问子资源。</p><p>写操作：原子性+独占，整个过程必须是个完整的过程，不能又其他线程插入其中。</p><p>ReentrankReadWriteLock就是典型的读写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用ReentrankReadWriteLock实现 写时上锁，读读共享</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mychace</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock=<span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String k,Object o)</span></span>&#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 开始写入"</span>);</span><br><span class="line">            map.put(k,o);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t  写入完成"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String k)</span></span>&#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 开始读取"</span>);</span><br><span class="line">        Object o=map.get(k);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t  读取完成"</span>+o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;学习三部曲：理论+实践+总结&lt;/p&gt;
&lt;h3 id=&quot;一、公平锁和非公平锁&quot;&gt;&lt;a href=&quot;#一、公平锁和非公平锁&quot; class=&quot;headerlink&quot; title=&quot;一、公平锁和非公平锁&quot;&gt;&lt;/a&gt;一、公平锁和非公平锁&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.ccgofa.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS-实现原子性</title>
    <link href="https://www.ccgofa.top/2019/04/26/CAS-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <id>https://www.ccgofa.top/2019/04/26/CAS-实现原子性/</id>
    <published>2019-04-26T04:26:43.000Z</published>
    <updated>2019-04-27T04:33:39.765Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>前面学习过volatile，它实现了内存的可见性，但是不保证原子性。于是我们引用了AtomicInteger类实现了非原子操作的线程安全，回过头来想，AtomicInteger类是如果实现 ++ 的原子性的呢。</p><h3 id="一、compareAndSet"><a href="#一、compareAndSet" class="headerlink" title="一、compareAndSet"></a>一、compareAndSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较符合预期就更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//加一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再点进去  unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们最后发现两个方法最后都有调用</p><p><strong>unsafe.compareAndSwapInt  (this, valueOffset, expect, update); </strong></p><p>那这是是个什么方法呢，unsafe类的这个方法是一个native的本地方法，它是底层的c类语言的对cup直接操作的原语。何为原语，它是一段不能被<strong>打断插入</strong>的对底层操作。</p><p>百度百科：原语 操作系统或<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。primitive or atomic action 是由若干个<a href="https://baike.baidu.com/item/机器指令/8553126" target="_blank" rel="noopener">机器指令</a>构成的完成某种特定功能的一段程序，具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p><p>OK我们要知道的就是它不能被分割了的，不会被别的操作再去干扰的机器命令。</p><p>那么在看看它传入的参数：</p><ul><li>this ：表示当前需要修改的对象</li><li>valueOffset：对象的内存地址，底层可以通过这个地址获得 this 对象的值。</li><li>expect：我们对this对象所期望的值</li><li>update：符合期望我们要将它更新的值</li></ul><p>2、那么到这里我们的<strong>compareAndSet compareAndSet(expect, update)</strong>方法就借助底层的<strong>compareAndSwapInt  (this, valueOffset, expect, update)</strong>，实现了是否可以跟新。</p><p>3、getAndAddInt（）又是如何借助compareAndSwapInt  实现安全自增呢。我们的++操作是一个必须要成功的操作，不能想compareAndSet一样更新不成功就不更新了。</p><ul><li><p>再来读读<strong>getAndAddInt(Object var1, long var2, int var4)</strong>源码，</p><p>var1=&gt;this，var2=&gt;地址，var4=&gt;需要增加的值，var5=&gt;就是自己线程工作内存里面的值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);<span class="comment">//读取主内存值到工作内存</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<span class="comment">//跟新不成功，自旋操作,重新读取var5，然后再进行compareAndSwapInt，注意这个方法是原语操作不会被打断，也就是这个操作过程中主内存里面的值是不会被修改的，这个var1也就是当前主内存里面的值。</span></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>我们模拟两个线程并发的执行这个操作：</p><p>1、A线程读取主内存值得到自己的  Avar5=3，然后被挂起了</p><p>2、B线程读取主内存值得到自己的  Bvar5=3，然后进行了加一写入主内存。</p><p>3、A线程唤起，进行compareAndSwapInt，但是读取的var1是4，和期望的var5=3不相等，那么不跟新进入下一次循环。</p><p>4、再次读取var5=4，执行compareAndSwapInt，对比没问题，更新操作，写入主内存。</p></li></ul><h3 id="二、CAS的问题"><a href="#二、CAS的问题" class="headerlink" title="二、CAS的问题"></a>二、CAS的问题</h3><p>1、ABA问题：那上面的来讲，要是B线程加完之后又减了，主内存中的值就还是3，那么A线程的跟新操作也会一次就成功。这就是ABA问题。有一种狸猫换太子的感觉</p><p>​      解决：加上一个版本号，每次操作都让版本号加一，比较更新时除了比较值意外还要比较版本号。AtomicStampedRefrence，就实现了这样的功能，</p><p>2、自旋的性能消耗问题</p><p>3、无法解决多个变量的原子操作，前面的方法也体现了，这个时只能对一个变量进行比较跟新，多个变量操纵就需要加锁了。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;前面学习过volatile，它实现了内存的可见性，但是不保证原子性。于是我们引用了AtomicInteger类实现了非原子操作的线程安全，回过头来想，AtomicInteger类是如果实现 ++ 的原子性的呢。&lt;/p&gt;
&lt;h3 id=&quot;一
      
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.ccgofa.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile轻量级锁-同步机制</title>
    <link href="https://www.ccgofa.top/2019/04/25/volatile%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.ccgofa.top/2019/04/25/volatile轻量级的同步机制/</id>
    <published>2019-04-25T11:50:23.000Z</published>
    <updated>2019-04-28T06:04:54.225Z</updated>
    
    <content type="html"><![CDATA[<p>不写点东西他还啥都没有</p><a id="more"></a><h3 id="1、Volatile-轻量级的同步机制"><a href="#1、Volatile-轻量级的同步机制" class="headerlink" title="1、Volatile:轻量级的同步机制"></a>1、Volatile:轻量级的同步机制</h3><ul><li>保证可见性</li><li>不保证原子性(不保证JMM需要的原子性，所以轻量)</li><li>禁止指令重拍</li></ul><h3 id="2、JMM-Java内存模型-：是一种抽象概念，并不正式存在，-是一种规范。"><a href="#2、JMM-Java内存模型-：是一种抽象概念，并不正式存在，-是一种规范。" class="headerlink" title="2、JMM(Java内存模型)：是一种抽象概念，并不正式存在， 是一种规范。"></a>2、JMM(Java内存模型)：是一种抽象概念，并不正式存在， 是一种规范。</h3><p>可见性、原子性、有序性</p><p><img src="https://img-blog.csdn.net/20160921182748551" alt="这里写图片描述"></p><p>变量存在主内存、线程变量需要拷贝到自己的工作内存，操作完成后再写入主内存。</p><p>线程A读取主内存值，线程B也读取主内存。</p><h3 id="3、从内存模型里去分析volatile的各种属性"><a href="#3、从内存模型里去分析volatile的各种属性" class="headerlink" title="3、从内存模型里去分析volatile的各种属性"></a>3、从内存模型里去分析volatile的各种属性</h3><ul><li>可见性 此时A线程修改x,并写入主内，此时要求其他线程知道这个x被改变。这部分其实在Java多线程学习中就有学习过，只不过没有从JMM层次这么深刻的去认识。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTo60</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number=<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、验证volatile可见性 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyDate date=<span class="keyword">new</span> MyDate();</span><br><span class="line">        <span class="comment">//第一个线程AAA，</span></span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">"\t  come in"</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>);&#125;<span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">           date.addTo60();</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;, <span class="string">"AAA"</span>).start();</span><br><span class="line">       <span class="keyword">while</span>(date.number==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1、如果number没有加volatile.这里无法发生，main线程无法读取到AAA线程修改的值，无法读取主内存中改变的值</span></span><br><span class="line">       <span class="comment">//2、如果加了volatile，就可以去读取到主内存改变的值</span></span><br><span class="line">       System.out.println(<span class="string">"main线程结束"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不保证原子性，JMM要求保证原子性，但是volatile不保证原子性。为什么volatile不能保证原子性呢。比如两个线程同时要对主内存中的i 进行 ++操作。++并不是原子操作，三步，读取i的值，将i加1，赋值给i。最后写入主内存。现在两个线程都完成了i++的操作了，然后写入操作是同步的，那么其中一个被挂起，写入之后主内存里面的值改变，这时候根据volatile的内存语义，其他线程应该通知得到这个值，但是被挂起的线程已经完成了i++的操作，所以这个可见来的有点晚，线程并不会再去对新的这个值去++操作，而是在很快的时间内就把自己加好的值写入主内存，这时候就会造成++操作的丢失。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不保证原子性操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyDate date=<span class="keyword">new</span> MyDate();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    date.addSum();</span><br><span class="line">                    date.sumByAtomic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"i"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"mian中： number="</span>+date.number);</span><br><span class="line">        <span class="comment">//number2是原子类型的  AtomicInteger</span></span><br><span class="line">        System.out.println(<span class="string">"main中： number2="</span>+date.number2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">mian中： number=98729</span></span><br><span class="line"><span class="comment">main中： number2=100000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//解决这个问题其实只要用上原子类</span></span><br></pre></td></tr></table></figure><ul><li>volatile重排规则，这是比较复杂的一个内容，涉及到JMM中happend-before，在代码编译运行过程中会对我们的代码进些一些重新排序，我们的基本要求是希望这些重新排序不要影响程序的运行结果。</li><li>volatile变量对于重拍有了这些内存语义：<ul><li>对于任何volatile写，其前面的操作都不能重拍到它的后面</li><li>对于任何volatile读，其后面的操作都不能重拍到它的前面</li><li>先volatile写  再volatile读，也不能重新排序。</li></ul></li><li>volatile要先读了，操作后面，操作好了，再写。如果硬是要先写再读也不能重排序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不写点东西他还啥都没有&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.ccgofa.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap--浅析</title>
    <link href="https://www.ccgofa.top/2019/04/23/ConcurrentHashMap-%E6%B5%85%E6%9E%90/"/>
    <id>https://www.ccgofa.top/2019/04/23/ConcurrentHashMap-浅析/</id>
    <published>2019-04-23T10:29:00.000Z</published>
    <updated>2019-05-05T11:58:45.428Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap简单小总结</p><a id="more"></a><p>最近一直在看《Java并发编程艺术》一书，书本内容还是相当的丰富，先从并发的底层实现、内存层次剖析了并发的实现，再到各种锁的底层实现原理，然后降到了Java中并发容器和框架。</p><p>前面的内容一直没时间整理，主要前面的知识底层读起来还是有难度的，一遍看过来感触不是很深。</p><p>今天学习了并发容器里面的ConcurrentHashMap和ConcurrentLinkedQueue，这里主要是写一些ConcurrentHashMap的理解。</p><p>Map家族是Java容器里非常重要的一部分，比如HashMap，Hashtable，ConcurrentHashMap。这三个中国HashMap线程不安全，后两者线程安全，但是Hashtable采用的是一种相当重量的锁，在对它进行操作的时候它会把整个表锁起来，是一种悲观锁。</p><p>而今天要讲的ConcurrentHashMap则时采用了一种更为巧妙地方式实现了线程安全。</p><ul><li>不锁全表，锁局部。</li><li>不锁所有操作，只锁有线程安全的操作。</li><li>对用量的计算（size)，采用一种乐观锁的机制。</li></ul><p>我阅读书本后书本总ConcurrentHashMap的结构大致是这样子的：ConcurrentHashMap的内部结构图：</p><p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1123993683,437526452&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=341&amp;s=5AA834639B9759CA0CF5E1DF0000C0B1" alt="img"></p><p>从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。</p><p>锁的思路是put才锁上局部的HashEntry，这些HashEntry都是volatile的，volatile是concurrent包一个非常重要的锁的机制，当然它底层关键的点还是CAS算法。这本书前面讲原理讲锁主要就是讲这些东西。</p><p>看完书后我打开电脑翻阅了一下concurrentHashMap的源码，发现似乎和书上的有所差异，我的是jdk1.8，后来看了网上发现书本上应该讲的是1.7及以前的版本。</p><p>1.8的ConcurrentHashMap的结构其实我觉得和HashMap结构非常相似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">    * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br></pre></td></tr></table></figure><p>但是不一样的是变量前都加了volatile。</p><p>卧槽源码越读越卧槽，大概看了下get  和 put 还有扩容，</p><p>get方法比较简单，和HashMap的思路差不多，先找到table对应的位置，再到链表中找对应的key，无需加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="comment">//根据hash值确定节点位置</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点  </span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果eh&lt;0 说明这个节点在树上 直接寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//否则遍历链表 找到对应的值并返回</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>put复杂一些:我们看到它锁的是节点，</p><p>先计算hash，找到对应位置，当然还有一系列的判断、table是否为空、判断时候需要扩容、判断时候需要调整链表为数、插入的时候还要判断key时候存在过了、其实都和HashMap相似。关键在于它将这个节点锁主其他线程不能访问，当然它的子节点也不能被访问到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//不允许 key或value为null</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//死循环 何时插入成功 何时跳出</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//如果table为空的话，初始化table</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//根据hash值计算出在table里面的位置 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果这个位置没有值 ，直接放进去，不需要加锁</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当遇到表连接点时，需要进行整合表的操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//fh〉0 说明这个节点是一个链表的节点 不是树的节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//在这里遍历链表所有的结点</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="comment">//如果hash值和key值相同  则修改对应结点的value值</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="comment">//如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span></span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果这个节点是树节点，就按照树的方式插入值</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前ConcurrentHashMap的元素数量+1</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还有就是关于size和扩容的操作，扩容是要复制表的，这个过程要考虑到线程的安全性问题，当然可以简单的单线程一步一步复制，但它是支持了多线程复制的。源码瞄了一两眼实在难看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentHashMap简单小总结&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.ccgofa.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="集合" scheme="https://www.ccgofa.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>spring重点归纳</title>
    <link href="https://www.ccgofa.top/2019/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.ccgofa.top/2019/04/22/计算机网络/</id>
    <published>2019-04-22T11:50:23.000Z</published>
    <updated>2019-05-10T13:53:17.703Z</updated>
    
    <content type="html"><![CDATA[<p>佛了</p><a id="more"></a><h1 id="计算机网络知识"><a href="#计算机网络知识" class="headerlink" title="计算机网络知识"></a>计算机网络知识</h1><h2 id="一、TCP-IP"><a href="#一、TCP-IP" class="headerlink" title="一、TCP/IP"></a>一、TCP/IP</h2><p>物理层：主要解决对接的标准，网络信号的传输，信道的多效利用</p><p>数据链路层：1、打包成贞、透明传输、可靠传输、差错检验。。。。。给资源加上MAC地址</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="一、IP协议"><a href="#一、IP协议" class="headerlink" title="一、IP协议"></a>一、IP协议</h4><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。每个计算机都有为一的IP地址</p><h4 id="TTL字段。"><a href="#TTL字段。" class="headerlink" title="TTL字段。"></a>TTL字段。</h4><p>这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。</p><p>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p><h3 id="二、ARP协议（地址解析协议）"><a href="#二、ARP协议（地址解析协议）" class="headerlink" title="二、ARP协议（地址解析协议）"></a>二、ARP协议（地址解析协议）</h3><p>这个协议是为IP协议服务的：</p><p>做三件事：先查开目的的IP地址在自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。</p><p>​        没有的话就会在自己的局域网中发广播获取目标IP的MAC地址</p><p>​        没有的话，就会发给网关路由器，等到MAC地址。</p><h3 id="描述RARP协议"><a href="#描述RARP协议" class="headerlink" title="描述RARP协议"></a>描述RARP协议</h3><p>答:RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。</p><h3 id="三、ICMP协议（网络控制报文协议）"><a href="#三、ICMP协议（网络控制报文协议）" class="headerlink" title="三、ICMP协议（网络控制报文协议）"></a>三、ICMP协议（网络控制报文协议）</h3><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p><p>​    网络层两个应用：</p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a><strong>ping</strong></h4><p>ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><p>ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。</p><p>ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。</p><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p><p>Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生   一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据  报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p>一个面向连接、可靠传输、面向字节流、能流量控制和阻塞控制，全双工。</p><h3 id="TCP对应的协议："><a href="#TCP对应的协议：" class="headerlink" title="TCP对应的协议："></a>TCP对应的协议：</h3><p>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</p><p>一个不连接、不可靠、面向报文、不能流量控制和阻塞控制，一对一、一对多、多对多、多对一，速度快。</p><h3 id="UDP对应的协议："><a href="#UDP对应的协议：" class="headerlink" title="UDP对应的协议："></a>UDP对应的协议：</h3><p>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p><p>第二次握手：  服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment  Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence  Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p><p>第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><p><strong>为什么要三次握手？</strong></p><p>主要是第三次握手的存在，避免了服务端等待确认的资源浪费，</p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><h3 id="四次分手"><a href="#四次分手" class="headerlink" title="四次分手"></a>四次分手</h3><p>第一次分手： 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入<strong>FIN_WAIT_1</strong>状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次分手： 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p>第三次分手： 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p>第四次分手：   主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p><strong>为什么要四次分手？</strong></p><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p><strong>为什么要等待2MSL？</strong></p><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p><p>原因有二：</p><ul><li>保证TCP协议的全双工连接能够可靠关闭</li><li>保证这次连接的重复数据段从网络中消失</li></ul><p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p><p>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>主要是借助 <strong>rwnd</strong>,接受端通过不断地响应rwnd的大小给接受端来实现流量的控制</p><p>发送窗口时不会大于接受窗口的。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>拥塞控制是有一个 cwnd,  拥塞窗口，这是发送端发送数据的窗口，</p><p>发送模拟：1、慢开始：发送的第一个数据只有一个包，cwnd的大小为1，如果能够顺利响应</p><p>​        2、继续满开始的节奏，成指数增长窗口的大小。</p><p>​        3、然后增长会到达一个慢增长限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</span><br><span class="line"></span><br><span class="line">    当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</span><br><span class="line">    当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</span><br><span class="line">    当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</span><br></pre></td></tr></table></figure><p>​        4、接着只会进行，cwnd一个一个的增长</p><p>​        5、知道增大到某一个值，发生了阻塞，丢包了，</p><p>​                就会向调整  ssthresh等于 档期cwnd大小的一半，然后cwnd的大小回到1，重新慢增长。</p><p><strong>快重传</strong></p><p>问题：（因为报文是每隔多少 响应一次的，比如M5才会响应，M3丢了，那么要等到M5，传好了之后才响应M3丢了）</p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p><p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让   发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了  接收方的四个对M2的确认，其中后三个都是重复确认。</p><p>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p><strong>快恢复</strong></p><p>问题：报文的丢失，可能不是网络拥塞的问题，那么当三个重复确认连续收到，说明网络没有阻塞，没有必要再从1满开始。所以有了快恢复。</p><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ul><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。</li><li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;佛了&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="https://www.ccgofa.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="网络" scheme="https://www.ccgofa.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简单的思考</title>
    <link href="https://www.ccgofa.top/2019/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://www.ccgofa.top/2019/04/20/设计模式简单的思考/</id>
    <published>2019-04-20T11:45:58.000Z</published>
    <updated>2019-04-26T04:28:45.401Z</updated>
    
    <content type="html"><![CDATA[<p>这几天学习的几种设计模式，其实学习的和肤浅，我平时做的东西也很少达到要用设计模式的地步，只是对他们有个初步的认识。</p><a id="more"></a><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h4 id="1-开闭原则-Open-Close-Principle（OCP）"><a href="#1-开闭原则-Open-Close-Principle（OCP）" class="headerlink" title="1.开闭原则 - Open Close Principle（OCP）"></a>1.开闭原则 - Open Close Principle（OCP）</h4><ul><li>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭</li><li>功能的扩展应该是定义新的类，而不是对原有的类进行修改</li></ul><h4 id="2-单一职责原则-Single-Responsibility-Principle（SRP）"><a href="#2-单一职责原则-Single-Responsibility-Principle（SRP）" class="headerlink" title="2.单一职责原则 - Single Responsibility Principle（SRP）"></a>2.单一职责原则 - Single Responsibility Principle（SRP）</h4><ul><li>不要存在多于一个导致类变更的原因</li></ul><h4 id="3-里士替换原则-Liskov-Substitution-Principle（LSP）"><a href="#3-里士替换原则-Liskov-Substitution-Principle（LSP）" class="headerlink" title="3.里士替换原则 - Liskov Substitution Principle（LSP）"></a>3.里士替换原则 - Liskov Substitution Principle（LSP）</h4><ul><li>定义一：所有引用基类的地方必须能透明地使用其子类的对象。</li><li>定义二：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</li></ul><h4 id="4-依赖倒置原则-Dependence-Inversion-Principle（DIP）"><a href="#4-依赖倒置原则-Dependence-Inversion-Principle（DIP）" class="headerlink" title="4.依赖倒置原则 - Dependence Inversion Principle（DIP）"></a>4.依赖倒置原则 - Dependence Inversion Principle（DIP）</h4><ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</li></ul><h4 id="5-接口隔离原则-Interface-Segration-Principle（ISP）"><a href="#5-接口隔离原则-Interface-Segration-Principle（ISP）" class="headerlink" title="5.接口隔离原则 - Interface Segration Principle（ISP）"></a>5.接口隔离原则 - Interface Segration Principle（ISP）</h4><ul><li>定义一：客户端不应该依赖它不需要的接口</li><li>定义二：类间的依赖关系应该建立在最小的接口上</li></ul><h4 id="6-迪米特法则-最少知道原则-Law-of-Demeter-or-Least-Knowledge-Principle（LoD-or-LKP）"><a href="#6-迪米特法则-最少知道原则-Law-of-Demeter-or-Least-Knowledge-Principle（LoD-or-LKP）" class="headerlink" title="6.迪米特法则/最少知道原则 - Law of Demeter or Least Knowledge Principle（LoD or LKP）"></a>6.迪米特法则/最少知道原则 - Law of Demeter or Least Knowledge Principle（LoD or LKP）</h4><ul><li>一个对象应该对其他对象保持最少的了解</li><li>这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。</li></ul><h2 id="一、创建者模型"><a href="#一、创建者模型" class="headerlink" title="一、创建者模型"></a>一、创建者模型</h2><h2 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h2><p>一个类只有一个对象：</p><p>数据库连接池，windows的任务管理器，配置文件加载器，spring的bean也是单例,springmvc，网站技术器都是单例</p><p>单例模式优点：只有一个实例减少系统的开销，</p><p>实现：饿汉模式，懒汉模式，静态内部类和局部静态块，枚举单例，双重检验锁，</p><p>CountDownLatch,等待其他线程执行完自己才结束，可以和join一样。就像一个技术器，一个线程执行完毕就让它减一，可以去调用CountDownLatch.await让主线程等待。</p><h2 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a>工厂模式：</h2><ul><li>简单工厂模式</li></ul><p>简单工厂对功能的拓展是需要对类修改的，那么就违背了acp（开闭原则）。</p><ul><li>工厂方法模式</li></ul><p>工厂方法模式满足了acp,但是造成了很多类增加了代码的复杂度，在生产的实际中反而简单工厂使用的更多</p><ul><li>抽象工厂模式</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>需要构建很多的零件一个复杂的类，我们需要构造（Builder）很多零件，还需要组装成（Director)一个复杂的对象。</p><p>通常建造者模式是和工厂模式搭配使用的。</p><ul><li>定义一个类，这个类需要有其他几个类组成</li><li>定义一构建者接口，定义创建组件的方法。定义一个组装者接口，返回那个复杂的类</li><li>实现构建者接口重写构建零件方法，通常这里可以和工厂模式结合，用简单工厂模式来实现各个零件的构建</li><li>实现组装者接口，组装者需要传入一个构建者，调用构建者构建零件的方法获得零件，由零件set来组成复杂类</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>静态代理</p><p>代理类包含被代理的类，其他行为代理类完成，关键步骤调用真实类完成</p><p>代理对象需要我们自己取定义，相对繁琐不灵活。</p><p>动态代理</p><p>动态的去生成我们的代理类，</p><p>生成这个代理类需要一个，handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Star star;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StarHandler</span><span class="params">(Star star)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写invoke方法，以后动态生成的代理的对象都会来执行这个方法。method.incoke是又返回对象的。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        method.invoke(star, args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//而动态生成代理的方法其实是反射的过程，需要类加载器，被代理类的Class信息，并且有一个处理器</span></span><br><span class="line"> Star proxy= (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Star.class&#125;,handler);</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>类与类之间的继承关系比较多，比如有一个电脑接口，下面有台式、笔记本、平板，下面又有联想、戴尔、神州。</p><p>这样不应该设置成联想台式、联想笔记本，这样不符合类的单一指责原则。</p><p>这个时候应该用桥接模式：定义品牌接口和样式接口，</p><p>桥接模式是典型的多对多的类的交互问题。</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式是一个对功能扩展常用的模式。</p><p>比如我现在有一个car类，下面可能有飞的car，智能car，水上漂的car，然后他们直接又可以组合，既可以飞又智能，这样如果没个不同类型的功能都定义一个子类，会让子类迅速膨胀。</p><p>那么需要装饰模式，装饰模式有一个关键点就是装饰者，装饰者持有最基本的cart这个对象，然后然一些单一功能的继承这个装饰者，去分别实现它们单一增加的功能。如果要组合的时候只要将一个功能的car传给另一个功能的car进行组合，就能实现功能的组合扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义顶级接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Icar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类，实现最基本的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Icar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"路上跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装饰者，持有基本类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuCar</span> <span class="keyword">implements</span> <span class="title">Icar</span></span>&#123;</span><br><span class="line">    Icar car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuCar</span><span class="params">(Icar car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      car.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现功能扩展的装饰好的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WortCar</span> <span class="keyword">extends</span> <span class="title">SuCar</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WortCar</span><span class="params">(Icar car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(car);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//功能扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"水上漂"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        extend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyCar</span> <span class="keyword">extends</span> <span class="title">SuCar</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyCar</span><span class="params">(Icar car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(car);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//功能扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"天上飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        extend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的io就是装饰模式的一种，装饰模式和桥接模式看上去很相似，都是去避免定义过多的类。</p><p>但实际它们解决的问题是不一样的，桥接是桥接类与类直接的组合关系，在多继承的情况下解决类组合复杂的问题。</p><p>而装饰模式是不能功能的扩展导致过多的定义类，是对新功能的扩展性问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天学习的几种设计模式，其实学习的和肤浅，我平时做的东西也很少达到要用设计模式的地步，只是对他们有个初步的认识。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="设计模式" scheme="https://www.ccgofa.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring重点归纳</title>
    <link href="https://www.ccgofa.top/2019/04/18/spring%E9%87%8D%E7%82%B9%E5%BD%92%E7%BA%B3/"/>
    <id>https://www.ccgofa.top/2019/04/18/spring重点归纳/</id>
    <published>2019-04-18T11:50:23.000Z</published>
    <updated>2019-04-28T06:02:56.144Z</updated>
    
    <content type="html"><![CDATA[<p>为什么会乱啊</p><a id="more"></a><h1 id="ioc"><a href="#ioc" class="headerlink" title="ioc"></a>ioc</h1><p>ioc：控制反转  </p><ul><li>比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象  </li><li>把对象的创建不是通过new方式实现，而是交给spring配置创建类对象  </li></ul><p>ioc底层原理使用技术 </p><p>（1）xml配置文件：在xml中配置类信息，类名和类路径。</p><p>（2）dom4j解析xml：解析xml获取类信息 </p><p>（3）工厂设计模式 和反射：这两个应该是结合的，工厂模式的设计理念，工厂制造bean的机制是反射。</p><ul><li><img src="H:/Github/SSM/spring/assets/ioc%E8%BF%87%E7%A8%8B1.png" alt="ioc过程"> </li></ul><h3 id="Bean标签常用属性"><a href="#Bean标签常用属性" class="headerlink" title="Bean标签常用属性"></a>Bean标签常用属性</h3><ol><li><p>id属性：定义的名称，id属性值名称任意命名   </p><ul><li>id属性值，不能包含特殊符号  </li><li>根据id值得到配置对象  </li></ul></li><li><p>class属性：创建对象所在类的全路径  </p></li><li><p>name属性：<br>功能和id属性一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊符号<br>老版本为兼容struts1的name属性，现在基本只是用id属性  </p></li><li><p>scope属性  </p><ul><li>singleton：默认值，单例（重点）  </li><li>prototype：多例（用在配置action）（重点）  </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"me.test.ioc.User"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="DL"><a href="#DL" class="headerlink" title="DL"></a>DL</h1><p>依赖注入：</p><ul><li>依赖：一个类需要用到另一个类，而往往我们需要去new另外一个类，这样就增加了耦合。就需要注入</li><li>注入：通过setter方法进行另一个对象实例设置。</li></ul><p>例如：l 例如：</p><p>​    class BookServiceImpl{</p><p>​        //之前开发：接口 = 实现类  （service和dao耦合）</p><p>​        //private BookDao bookDao = new BookDaoImpl();</p><pre><code>//spring之后 （解耦：service实现类使用dao接口，不知道具体的实现类）</code></pre><p>​        private BookDao bookDao;</p><p>​        setter（BookDao bookDao) 方法，传入一个bookDao实现注入。</p><p>   }</p><p>​    模拟spring执行过程</p><p>​    创建service实例：BookService bookService = new BookServiceImpl()        –&gt;IoC  <bean></bean></p><p>​    创建dao实例：BookDao bookDao = new BookDaoImple()                –&gt;IoC</p><p>​    将dao设置给service：bookService.setBookDao(bookDao);                –&gt;DI   <property></property></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">模拟spring执行过程</span></span><br><span class="line"><span class="comment">创建service实例：BookService bookService = new BookServiceImpl()IoC  &lt;bean&gt;</span></span><br><span class="line"><span class="comment">创建dao实例：BookDao bookDao = new BookDaoImpl()IoC</span></span><br><span class="line"><span class="comment">将dao设置给service：bookService.setBookDao(bookDao);DI   &lt;property&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;property&gt; 用于进行属性注入</span></span><br><span class="line"><span class="comment">name： bean的属性名，通过setter方法获得</span></span><br><span class="line"><span class="comment">setBookDao ##&gt; BookDao  ##&gt; bookDao</span></span><br><span class="line"><span class="comment">ref ：另一个bean的id值的引用</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建service --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookServiceId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.b_di.BookServiceImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bookDao"</span> <span class="attr">ref</span>=<span class="string">"bookDaoId"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建dao实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookDaoId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.b_di.BookDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="属性的注入"><a href="#属性的注入" class="headerlink" title="属性的注入"></a>属性的注入</h2><p>我们都知道，一个类的私有属性其他人想去对其定义，通常有两种方法</p><ul><li><p>一种是在构造这个类的对象的时候就传入相关的属性信息</p></li><li><p>还有一种是通过setter方法来传入属性</p></li></ul><p>比如一个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persen</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persen</span> <span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类提供了公共的构造方法和 set方法，这都是可以对对象属性的进行定义的，那么如果这个类的实例化交给了sping容器来完成，它是怎么实现这两种属性的注入的呢。</p><ul><li>构造方法</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 构造方法注入 </span></span><br><span class="line"><span class="comment">* &lt;constructor-arg&gt; 用于配置构造方法一个参数argument</span></span><br><span class="line"><span class="comment">name ：参数的名称</span></span><br><span class="line"><span class="comment">value：设置普通数据</span></span><br><span class="line"><span class="comment">ref：引用数据，一般是另一个bean id值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">index ：参数的索引号，从0开始 。如果只有索引，匹配到了多个构造方法时，默认使用第一个。</span></span><br><span class="line"><span class="comment">type ：确定参数类型</span></span><br><span class="line"><span class="comment">例如：使用名称name</span></span><br><span class="line"><span class="comment">&lt;constructor-arg name="username" value="jack"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">&lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">例如2：【类型type 和  索引 index】</span></span><br><span class="line"><span class="comment">&lt;constructor-arg index="0" type="java.lang.String" value="1"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">&lt;constructor-arg index="1" type="java.lang.Integer" value="2"&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.f_xml.a_constructor.User"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>set方法：类的注入也是用set方法</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- setter方法注入 </span></span><br><span class="line"><span class="comment">* 普通数据 </span></span><br><span class="line"><span class="comment">&lt;property name="" value="值"&gt;</span></span><br><span class="line"><span class="comment">等效</span></span><br><span class="line"><span class="comment">&lt;property name=""&gt;</span></span><br><span class="line"><span class="comment">&lt;value&gt;值</span></span><br><span class="line"><span class="comment">* 引用数据</span></span><br><span class="line"><span class="comment">&lt;property name="" ref="另一个bean"&gt;</span></span><br><span class="line"><span class="comment">等效</span></span><br><span class="line"><span class="comment">&lt;property name=""&gt;</span></span><br><span class="line"><span class="comment">&lt;ref bean="另一个bean"/&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.f_xml.b_setter.Person"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pname"</span> <span class="attr">value</span>=<span class="string">"阳志"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>1234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"homeAddr"</span> <span class="attr">ref</span>=<span class="string">"homeAddrId"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"companyAddr"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"companyAddrId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"homeAddrId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.f_xml.b_setter.Address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"addr"</span> <span class="attr">value</span>=<span class="string">"阜南"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tel"</span> <span class="attr">value</span>=<span class="string">"911"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"companyAddrId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.f_xml.b_setter.Address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"addr"</span> <span class="attr">value</span>=<span class="string">"北京八宝山"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tel"</span> <span class="attr">value</span>=<span class="string">"120"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然还可以注入一些复杂的数据，比如集合，链表等等，它们的注入就是在<property>标签下面再加上对应的结构标签。</property></p><p>name：注入属性的名字</p><p>ref：注入的类id      value：注入普通的值</p><h1 id="IOC和Dl区别"><a href="#IOC和Dl区别" class="headerlink" title="IOC和Dl区别"></a>IOC和Dl区别</h1><ul><li>IOC：控制反转，把对象创建交给spring进行配置</li><li>DI：依赖注入，向类里面的属性中设置值</li><li>关系：依赖注入不能单独存在，需要在IOC基础之上完成操作</li></ul><p>其实这个区别的化还是没什么好说的，更重要的是明白这两个东西，我觉得不是一个类型的。</p><h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><ol><li>Joinpoint(连接点): 类里面可以被增强的方法，这些方法称为连接点  </li><li><strong>Pointcut(切入点)</strong>:所谓切入点是指我们要对哪些Joinpoint进行拦截的定义  </li><li><strong>Advice(通知/增强)</strong>:所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)  </li><li><strong>Aspect(切面)</strong>: 是切入点和通知（引介）的结合  </li><li>Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field  </li><li>Target(目标对象):代理的目标对象(要增强的类)  </li><li>Weaving(织入):是把增强应用到目标的过程<br>把advice 应用到 target的过程</li><li>Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类 </li></ol><h3 id="AOP中文名就是切面编程，前面编程有三个关键点"><a href="#AOP中文名就是切面编程，前面编程有三个关键点" class="headerlink" title="AOP中文名就是切面编程，前面编程有三个关键点"></a>AOP中文名就是切面编程，前面编程有三个关键点</h3><ul><li>一个是我们要被切的基本业务类，也就是目标对象</li><li>一个是通知增强的类，就是要对我们的目标类进行前后异常操作的。</li><li>还有一个就是把它们结合其他的形成的切面了，一个类被AOP增强之后就会形成一个它的代理类，这个代理类不仅仅有目标类的方法，还有增强类的方法，并且能让增强类方法在合适的位置出现。</li></ul><p>spring是用cglib字节码操作，结合代理模式和工厂模式和反射实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务业务被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切入类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结合类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyService <span class="title">createService</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">final</span> MyAspect aspect=<span class="keyword">new</span> MyAspect();</span><br><span class="line">       <span class="keyword">final</span> MyService service=<span class="keyword">new</span> MyService();</span><br><span class="line">       Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">       <span class="comment">//确定父类</span></span><br><span class="line">       enhancer.setSuperclass(MyService.class);</span><br><span class="line">       <span class="comment">/* 设置回调函数 , MethodInterceptor接口 等效 jdk InvocationHandler接口</span></span><br><span class="line"><span class="comment">        *      intercept() 等效 jdk实现代理模式的 invoke()</span></span><br><span class="line"><span class="comment">        * 参数1、参数2、参数3：以invoke一样</span></span><br><span class="line"><span class="comment">        * 参数4：methodProxy 方法的代理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; &#123;</span><br><span class="line">           aspect.before();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//两种调用业务的方法1、2.</span></span><br><span class="line">           <span class="comment">//1、执行目标类的方法</span></span><br><span class="line">           Object objet=method.invoke(service,objects);</span><br><span class="line">           <span class="comment">//2、执行代理类的父类 ，执行目标类 （目标类和代理类 父子关系）</span></span><br><span class="line">           methodProxy.invokeSuper(o,objects);</span><br><span class="line"></span><br><span class="line">           aspect.after();</span><br><span class="line">           <span class="keyword">return</span> objet;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">//创建代理</span></span><br><span class="line">       MyService proxService = (MyService) enhancer.create();</span><br><span class="line">       <span class="keyword">return</span> proxService;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种代理模式也可以用JDK自带的反射包的proxy和invokhandler实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactorybyjdk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Service <span class="title">createService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyAspect aspect = <span class="keyword">new</span> MyAspect();</span><br><span class="line">        Service service = <span class="keyword">new</span> MyService();</span><br><span class="line">        Service serviceProxy = (Service) Proxy.newProxyInstance(</span><br><span class="line">                service.getClass().getClassLoader(),</span><br><span class="line">                service.getClass().getInterfaces(),</span><br><span class="line">                (InvocationHandler) (proxy, method, args) -&gt; &#123;</span><br><span class="line">                    aspect.before();</span><br><span class="line">                    Object object=method.invoke(service,args);</span><br><span class="line">                    aspect.after();</span><br><span class="line">                    <span class="keyword">return</span> object;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> serviceProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring通过配置实现AOP"><a href="#spring通过配置实现AOP" class="headerlink" title="spring通过配置实现AOP"></a>spring通过配置实现AOP</h3><p>这个工厂肯定不是我们手写的，因为spring天生就是来创建bean的，实现AOP我们只要编写好我们的目标类和切入类，讲它们放入spring容器，然后将他们相切，怎么切呢</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3 aop编程 </span></span><br><span class="line"><span class="comment">3.1 导入命名空间</span></span><br><span class="line"><span class="comment">3.2 使用 &lt;aop:config&gt;进行配置</span></span><br><span class="line"><span class="comment">proxy-target-class="true" 声明时使用cglib代理</span></span><br><span class="line"><span class="comment">&lt;aop:pointcut&gt; 切入点 ，从目标对象获得具体方法</span></span><br><span class="line"><span class="comment">&lt;aop:advisor&gt; 特殊的切面，只有一个通知 和 一个切入点</span></span><br><span class="line"><span class="comment">advice-ref 通知引用</span></span><br><span class="line"><span class="comment">pointcut-ref 切入点引用</span></span><br><span class="line"><span class="comment">3.3 切入点表达式（重要）</span></span><br><span class="line"><span class="comment">execution(* com.itheima.c_spring_aop.*.*(..))</span></span><br><span class="line"><span class="comment">选择方法         返回值任意   包             类名任意   方法名任意   参数任意</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1 创建目标类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceId"</span> <span class="attr">class</span>=<span class="string">"路径"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2 创建切面类（通知） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectId"</span> <span class="attr">class</span>=<span class="string">"路径"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">方法1：</span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"切入点表达式"</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span>  <span class="attr">advice-ref</span>=<span class="string">"通知引用"</span> <span class="attr">pointcut-ref</span>=<span class="string">"切入点的引用"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">方法2：</span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:advisor</span>  <span class="attr">advice-ref</span>=<span class="string">"通知引用"</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--AspectJ xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"切面类"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"切入点表达式"</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:before</span>&gt;</span>  前置</span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:afterReturning</span>  <span class="attr">returning</span>=<span class="string">"第二个参数名称"</span>&gt;</span> 后置</span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:around</span>&gt;</span> 环绕</span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:afterThrowing</span> <span class="attr">throwing</span>=<span class="string">"第二。。。"</span>&gt;</span> 抛出异常</span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:after</span>&gt;</span> 最终</span><br></pre></td></tr></table></figure><p>AspectJ 是AOP实现的一个框架，整合到了spring中，前面<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a> 特殊的切面，只有一个通知 和 一个切入点，那么如果我有多个需要切入的点或者说我要在这个切入点的不能位置进行操作，那么就需要AspectJ，如上面配置，它实现了五个位置对切入点的操作。</p><p>明天继续复习事务————</p><p>明天到来了</p><h1 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a>spring事务</h1><h2 id="1-1-回顾事务"><a href="#1-1-回顾事务" class="headerlink" title="1.1 回顾事务"></a><strong>1.1</strong> <strong>回顾事务</strong></h2><p>l 事务：一组业务操作ABCD，要么全部成功，要么全部不成功。</p><p>l 特性：ACID</p><p>​    原子性：整体</p><p>​    一致性：完成</p><p>​    隔离性：并发</p><p>​    持久性：结果</p><p>l 隔离问题：</p><p>​    脏读：一个事务读到另一个事务没有提交的数据</p><p>​    不可重复读：一个事务读到另一个事务已提交的数据（update）</p><p>​    虚读(幻读)：一个事务读到另一个事务已提交的数据（insert）</p><p>l 隔离级别：</p><p>​    read uncommitted：读未提交。存在3个问题</p><p>​    read committed：读已提交。解决脏读，存在2个问题</p><p>​    repeatable read：可重复读。解决：脏读、不可重复读，存在1个问题。</p><p>​    serializable ：串行化。都解决，单事务。</p><p>l PlatformTransactionManager  平台事务管理器，spring要管理事务，必须使用事务管理器</p><p>​    进行事务配置时，必须<strong>配置事务管理器</strong>。</p><p>l TransactionDefinition：事务详情（事务定义、事务属性），spring用于确定事务具体详情，</p><p>​    例如：隔离级别、是否只读、超时时间 等</p><p>​    进行事务配置时，<strong>必须配置详情</strong>。spring将配置项封装到该对象实例。</p><p>l TransactionStatus：事务状态，spring用于记录当前事务运行状态。例如：是否有保存点，事务是否完成。</p><p>​    spring底层根据状态进行相应操作。</p><p>AOP是事务的基础</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么会乱啊&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="spring" scheme="https://www.ccgofa.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis学习心得</title>
    <link href="https://www.ccgofa.top/2019/04/17/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.ccgofa.top/2019/04/17/Linux性能分析命令/</id>
    <published>2019-04-17T05:22:07.000Z</published>
    <updated>2019-05-01T07:28:17.230Z</updated>
    
    <content type="html"><![CDATA[<p>简单罗列一些Linux和jvm性能分析的工具和命令、</p><a id="more"></a><p>Linux性能分析命令</p><ul><li><p>top(整机）：（uptime)：查开整机性能，cup和load average（平局超过0.6）就比较高了</p></li><li><p>vmstat -n 2 3（cpu)  :  看procs: 轮转进程数  cpu ：us+sy   mpstat   pidstat。</p></li><li><p>free（内存）:  free m   free g（后面是单位，兆还是g） </p></li><li><p>df（硬盘）: </p></li><li><p>iostat（磁盘io)  ：</p></li><li><p>ifstat（网络io）：</p></li><li><p>pidstat：查看具体进程号对应信息： pidstat -r -p 13084 1</p><ul><li><p>pidstat命令指定采样周期和采样次数，命令形式为”pidstat [option] interval [count]”，以下pidstat输出以2秒为采样周期，输出10次cpu使用统计信息：</p></li><li><p><strong>cpu使用情况统计(-u)</strong></p></li><li><strong>内存使用情况统计(-r)</strong></li><li><strong>IO情况统计(-d)</strong></li></ul></li></ul><p>JVM性能分析工具</p><ul><li>jps （虚拟机进程）like ps</li><li>jstat （统计信息监视）like  pidstat，可以查看进程的某种信息，比如-gc -gcold</li><li>jinfo（配置信息）</li><li>jmap  (堆内存，dump heap，查看进程堆信息)  </li><li>jstack（堆栈跟踪工具）  </li><li>jhat  （堆转储快照分析） </li></ul><p>CUP占用过高：</p><p>​        分析流程: top==&gt;找到哪个程序，记录pid</p><p>​        用 jps -l 或者 ps -ef | grep -v grep 得到进程 id</p><p>​        ps -mp  进程id  -o  THREAD，tid,time   得到线程 id  （-m 显示所有线程，-p进程号，-o 用户自定义格式）</p><p>​        <strong>线程id变成16 进制</strong>      或者用 ”printf “%x\n”</p><p>​        jstack 进程号  |  grep <strong>(16进制线程号)</strong>  -A60</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单罗列一些Linux和jvm性能分析的工具和命令、&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="操作系统" scheme="https://www.ccgofa.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>redis学习心得</title>
    <link href="https://www.ccgofa.top/2019/04/17/redis%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <id>https://www.ccgofa.top/2019/04/17/redis学习心得/</id>
    <published>2019-04-17T05:22:07.000Z</published>
    <updated>2019-04-26T04:27:50.154Z</updated>
    
    <content type="html"><![CDATA[<p>学习redis已经有几天了，主要都是断断续续的，这几天看Java高级知识也花了很多时间，今天来给redis的一些知识点做一下总结回顾。</p><a id="more"></a><h2 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h2><p>介绍Redis之前，先了解下NoSQL （Not noly SQL）不仅仅是SQL</p><p>属于非关系型数据库；Redis就属于非关系型数据库</p><p>传统的Mysql ,oracle ,sql server 等 都是关系型数据库</p><p>redis是基于内存的，单线程操作的，多路IO(NIO)复用的，key value型缓存数据库。</p><h2 id="为什么要学redis"><a href="#为什么要学redis" class="headerlink" title="为什么要学redis"></a>为什么要学redis</h2><p>为什么需要NoSQL，主要应对以下问题，传统关系型数据库力不从心</p><p>High performance -高并发读写</p><p>Huge Storage-海量数据的高效率存储和访问</p><p>High Scalablility &amp;&amp; High Availability 高可扩展性和高可用性</p><h2 id="redis主要的数据类型"><a href="#redis主要的数据类型" class="headerlink" title="redis主要的数据类型"></a>redis主要的数据类型</h2><p>1.STRING redis的STRING十分神奇，它不单指字符串，还可以代表数值型数据，可以进行字符串以及数值的各种处理 </p><p>2.LIST redis的列表，列表的每一个节点都包含了一个字符串 LIST可以从表头和表尾push和put数据，也可以根据偏移量对链表进行修剪（trim）；读取单个/多个元素，查询或者删除元素 </p><p>3.SET 包含字符串的无序收集器，并且包含的每一个字符串都是唯一的 操作就是基本的增删改查，计算交集，并集以及差集，并且可以随机获取元素 </p><p>4.ZSET 有序集合 字符串成员（member）与浮点数分值（sorce）之间的有序映射，元素排列顺序由分值决定 操作就是基本的增，查，删单个元素，获取分值范围内的或者成员来获取元素 </p><p>5.HASH 包换键值对的无序列表 增，删，查单个键值对，获取所有键值对</p><h2 id="redis一些高级特性"><a href="#redis一些高级特性" class="headerlink" title="redis一些高级特性"></a>redis一些高级特性</h2><p><strong>【聊聊redis持久化 – 两种方式】</strong></p><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p><p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p><p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p><p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p><p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p><p><strong>【聊聊redis持久化 – RDB】</strong></p><p>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</p><p>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p><p>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p><p>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</p><p><strong>【聊聊redis持久化 – AOF】</strong></p><p>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</p><p>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</p><p>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</p><p>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</p><p>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</p><p>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</p><p>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。</p><p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p><p>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p><p>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</p><p>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p><p>1.备份被写坏的AOF文件<br> 2.运行redis-check-aof –fix进行修复<br> 3.用diff -u来看下两个文件的差异，确认问题点<br> 4.重启redis，加载修复后的AOF文件</p><p><strong>【聊聊redis持久化 – AOF重写】</strong></p><p>AOF重写的内部运行原理，我们有必要了解一下。</p><p>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p><p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p><p>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p><p>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p><p><strong>【聊聊redis持久化 – 如何选择RDB和AOF】</strong></p><p>对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。</p><p><strong>【聊聊主从 – 用法】</strong></p><p>像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。</p><p>主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</p><p>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</p><p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p><p>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</p><p><strong>【聊聊主从 – 同步原理】</strong></p><p>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</p><p>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</p><p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</p><p>主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication   offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</p><p>增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</p><p><strong>【聊聊redis的事务处理】</strong></p><p>众所周知，事务是指“一个完整的动作，要么全部执行，要么什么也没有做”。</p><p>在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。</p><p> 1.MULTI用来组装一个事务；<br> 2.EXEC用来执行一个事务；<br> 3.DISCARD用来取消一个事务；<br> 4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。</p><p>redis没有实际的事务的感念，这里的事务也不想关系型数据库里的事务那样。当在组装的时候某个语句组装没出错，比如取一个空key，那么在执行的时候也只有这一句是不行的。但在exec执行前就报出来语法错误则整个事务失败。</p><h2 id="redis面试题"><a href="#redis面试题" class="headerlink" title="redis面试题"></a>redis面试题</h2><h3 id="Redis与Memcached的区别与比较"><a href="#Redis与Memcached的区别与比较" class="headerlink" title="Redis与Memcached的区别与比较"></a>Redis与Memcached的区别与比较</h3><p>1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</p><p>2 、Redis支持数据的备份，即master-slave模式的数据备份。</p><p>3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</p><p>4、 redis的速度比memcached快很多</p><p>5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p><h3 id="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"><a href="#MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）" class="headerlink" title="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"></a>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）</h3><p>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol><p>lru算法是一种用hashmap和链表实现的算法，没使用一次就将数据放在链表的最后，要回收的时候就回收前面的。</p><h3 id="Redis常见性能问题和解决方案"><a href="#Redis常见性能问题和解决方案" class="headerlink" title="Redis常见性能问题和解决方案:"></a>Redis常见性能问题和解决方案:</h3><p>1、Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件<br>2、如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次<br>3、为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内<br>4、尽量避免在压力很大的主库上增加从库</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习redis已经有几天了，主要都是断断续续的，这几天看Java高级知识也花了很多时间，今天来给redis的一些知识点做一下总结回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.ccgofa.top/categories/java/"/>
    
    
      <category term="数据库" scheme="https://www.ccgofa.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
