<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM学习笔记（二）]]></title>
    <url>%2F2019%2F04%2F15%2FJVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[继续JVM知识，这次主要总分解类得加载，深入了解JVM这本书我就先看这部分，实在是难啃，很多名词都没接触过，知识概念性得东西又多，关于调优部分一些常用得调优工具我就不总结了，后面有机会再来读读这本书 类加载机制 类加载得全过程 什么时候类加载 类加载器 一、类加载全过程 先看看一张完整的类的生命周期图 整个过程分为七步，其中验证、准备、解析属于连接，前面五部总的来说就是类的加载，加载、验证、准备、初始化和卸载这些步骤的顺序是固定的，其他的可能不确定，解析可能在初始化之后，比如反射机制。 下面主题看看加载的步骤： 加载加载主要做三件事： 通过一个类的全限定名来获取定义此类的二进制字节流，后面介绍类加载器时，会自定义一个类加载器，就是需要一个io的字节流，来实现类的加载。 将字节流的静态储存结构转化为方法区的运行时的数据结构；也就是类加载先会去加载那些静态的资源放入方法区。 还有就是会在堆里面生成一个 java.lang.class的对象，作为访问这个类在方法区里面内容的接口。 验证验证的几个内容： 文件格式的验证：检查是不是以魔数开头，版本对不对。。。 元数据验证：对一些类需要的数据进行验证，必有这个类有没有父类，这个父类是不是不能被继承的，父类是不是抽象的 字节码验证：这是比较麻烦的一个部分，主要是验证程序是不是语义合法，是不是逻辑符合，这个其实idea也会去做….所以在编译器调优时可以把JVM 的这些验证功能关掉。-Xverify:none 符号引用验证：这个其实是在解析的时候发生。是对常量池中各种符号引用的一种验证 准备准备阶段就是为类的变量分配内存，并设置类变量的初始值的阶段，注意的是这个阶段只是对类变量（被static修饰的变量）进行准备，不包括实例变量。 public static int a=123; 这里再准备阶段a 的值将只是 0，不是123，因为只是给一个初始值，要解析的时候才会真正被复制。 public final static int a=123; 这里的a在准备阶段是123，因为加了final那么就会为变量赋值—-注意一下 解析 解析的主要目的是：将虚拟机常量池中的符号引用替换为直接引用的过程。 解释一下符号引用和直接引用：比如在方法A中使用方法B，A（）{B（）；}，这里的B（）就是符号引用，初学java时我们都是知道这是java的引用，以为B指向B方法的内存地址，但是这是不完整的，这里的B只是一个符号引用，它对于方法的调用没有太多的实际意义，可以这么认为，他就是给程序员看的一个标志，让程序员知道，这个方法可以这么调用，但是B方法实际调用时是通过一个指针指向B方法的内存地址，这个指针才是真正负责方法调用，他就是直接引用。 初始化初始化简单来讲就是去执行 &lt; clinit&gt;()构造方法的过程，为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值。 对 类变量 和 静态语句块 进行赋值动作，这个过程先后就是开谁在前谁在后。 下面代码值得一看 123456789public class Test1 &#123; static &#123; i=0; //可以赋值，即使还没定义，但是不能访问，也就是你不能对i进行其他操作，除了赋值 &#125; static int i=1; public static void main(String[] args)&#123; System.out.println(i); //结果为1，如果调整静态块顺序结构就为0. &#125;&#125; 12345678910111213//对子类的静态值调用会先去加载父类的 static class Parent&#123; public static int A=1; static &#123; A=2; &#125; &#125; static class Sun extends Parent&#123; public static int B=A; &#125; public static void main(String[] args)&#123; System.out.println(Sun.B); //打印结果为2 &#125; 而且静态块的赋值操作还是阻塞的。 二、什么时候类加载类的主动加载主动加载就是出现下面情况，会里面对类进行初始化，当然初始化之前肯定还有加载、验证、准备、解析。。 java对类的主动使用有五种情况： 创建类的实例 (new），或者定义类用 final 修饰 访问某个类或接口的静态变量，或者对该静态变量赋值 ，调用类的静态方法 。类的static你要用就得先加载这个类。 反射（如Class.forName(“com.shengsiyuan.Test”)） 初始化一个类的子类（先初始化所有的父类，最后初始化本身，接口除外，类初始化的时候，它所实现的接口不会初始化，就算字接口初始化，父接口也不会初始化，只有当程序调用接口的静态变量的时候才会导致接口的初始化） Java虚拟机启动时被标明为启动类的类，如main方法的那个类。 写点代码吧,下面代码差不多概括了2和4和5，1好理解，3记一下 12345678910111213141516171819202122232425262728class Parent&#123; static &#123; System.out.println("我是妈妈，我要先被加载"); &#125;&#125;class Son extends Parent&#123; static &#123; System.out.println("我是儿子，我被加载了"); &#125; public static void function()&#123; System.out.println("我是儿子的静态方法，调用我要先加载我"); &#125;&#125;public class Test3 &#123; static &#123; System.out.println("我是有main方法的类，我第一个加载"); &#125; public static void main(String[] args)&#123; Son.function(); &#125;&#125; /** * 打印结果： * 我是有main方法的类，我第一个加载 * 我是妈妈，我要先被加载 * 我是儿子，我被加载了 * 我是儿子的静态方法，调用我要先加载我 */ 类的被动加载有以下三种情况 访问类的静态变量，只会去初始化这个变量真正被定义的类。 new一个类的数组是不会马上去加载这个类的，只有最后操作数组具体对象才会加载。 访问类的final变量不会去加载这个类 也写点代码吧。很有意义的代码，值得思考 123456789101112131415161718192021class Parent2&#123; static &#123; System.out.println("我是妈妈，我要先被加载"); &#125; public static int value=123;&#125;class Son2 extends Parent2&#123; public static final int sonvalue=123; static &#123; System.out.println("我是儿子，我被加载了"); &#125;&#125;public class Test4 &#123; public static void main(String[] args)&#123; System.out.println(Son2.value); //Son2不加载 Son2[] son2s=new Son2[10]; //Son2不加载 System.out.println(Son2.sonvalue); //Son2不加载 &#125;&#125;//打印结果是之后Parent2被加载了 三、类加载器JDK 默认提供了如下几种ClassLoader Bootstrp loaderBootstrp 加载器是用C++语言写的，它是在Java虚拟机启动后初始化的，它主要负责加载%JAVA_HOME%/jre/lib,-Xbootclasspath参数指定的路径以及%JAVA_HOME%/jre/classes中的类。 ExtClassLoader Bootstrp loader 加载ExtClassLoader,并且将ExtClassLoader的父加载器设置为Bootstrp loader.ExtClassLoader是用Java写的，具体来说就是 sun.misc.Launcher$ExtClassLoader，ExtClassLoader主要加载%JAVA_HOME%/jre/lib/ext，此路径下的所有classes目录以及java.ext.dirs系统变量指定的路径中类库。 AppClassLoader Bootstrp loader 加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader。AppClassLoader也是用Java写成的，它的实现类是 sun.misc.Launcher$AppClassLoader，另外我们知道ClassLoader中有个getSystemClassLoader方法,此方法返回的正是AppclassLoader.AppClassLoader主要负责加载classpath所指定的位置的类或者是jar文档，它也是Java程序默认的类加载器。 综上所述，它们之间的关系可以通过下图形象的描述： 为什么要有三个类加载器，一方面是分工，各自负责各自的区块，另一方面为了实现委托模型。 双亲委派模型就是一个类加载器收到类加载的要求，它先不会去加载，会先让上一层的的类加载器去加载，一致到启动类加载器，然后启动类加载器就回去加载，它加载不了又丢回给扩展类加载器，下来每个都会去是试着加载知道加载出来，到最后加载不出来就报错。 目的就是为了安全，对Java层序稳定性有很重要的作用。 破坏双亲委派模型这个就是类加载器收到类加载的要求，它就回去加载，它加载不了再去个ParentClassLoader加载。比如tomcat就是这个干的，这样做灵活性更高。 自定义类加载器最后写一个自定义的文件类加载器，很简单，实现了双亲委派模型。先丢个parent。也就是会丢个App-ClassLoader。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir) &#123; this.rootDir=rootDir; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class c=findLoadedClass(name); if(c!=null)&#123; //已经加载过了 return c; &#125;else&#123; ClassLoader parent=this.getParent(); try &#123; c=parent.loadClass(name); &#125;catch (Exception e) &#123; &#125; if(c!=null)&#123; return c; &#125;else&#123; byte[] classdate= new byte[0]; try &#123; classdate = getClassDate(name); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if(classdate==null)&#123; throw new ClassNotFoundException(); &#125;else&#123; c=defineClass(name,classdate,0,classdate.length); &#125; &#125; &#125; return c; &#125; private byte[] getClassDate(String className) throws IOException &#123; String path=rootDir+"/"+className.replace('.','/'); InputStream is = null; StringBuffer a=new StringBuffer(); try &#123; is=new FileInputStream(path); byte[] buffer=new byte[1024]; int tmp=0; while((tmp=is.read(buffer))!=-1)&#123; a.append(buffer); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(is!=null)&#123; is.close(); &#125; &#125; return a.toString().getBytes(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F14%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java多线程编程核心技术也看了大半了，感觉时候做点总结了，这本书看着还是比较轻松愉快的，推荐推荐。书本用的了很多事例去讲解多线程的种种API，作为多线程学习还是很不错的。 Java多线程开山篇我就不一点一点总结了，毕竟别人总结的已经很好了，需要总体复习的时候看看别人总结的就挺不错了，学习时间够写博客时间自然得zip一下。 Thread 主要API一、体验多线程继承Thread类，实现Runnable接口，一般推荐后面的方法，因为继承只能有一个嘛。 1234567891011121314151617/** * 体验线程 * 线程的调用不是跟随程序书写的先后来决定的 */class Tread extends Thread&#123; @Override public void run() &#123; System.out.println("我被调用了"); &#125;&#125;public class Thread01 &#123; public static void main(String[] args)&#123; Tread s=new Tread(); s.start(); System.out.println("主线程被调用了"); &#125;&#125; 二、Thread主要的方法基本方法 currentThread() 获取当前线程 isAlive 判断线程时候已经结束 sleep 让线程进入阻塞状态，并且是规定时间的 getId 获得线程的ID，这相当于给每个线程编号，每个线程都有一个自己的ID 线程的停止 1234567891011121314151617181920212223242526272829303132333435363738/** * 线程的停止： * 1、run方法结束线程自然停止 * 2、调用stop方法，强行停止线程，但这是不安全的，不建议使用 * 3、调用interruput，这个方法并不是马上的停止线程，而是基于线程一个 interruput的值得改变 * 作为一个标记，通过这个boolen值得改变，进行if判断来终止循环，从而终止线程。 * interruputed是当前线程又类调用得，它得调用会使得true变成false,而且测试来看 * 调用interruput方法，先interruputed变成true，后isInterruputed变为true， * 因为我多次测试，用interruputed方法作为判断条件，打印得isInterruputed得结果依然还是false * Interruputed方法得调用，不会改变自身得值 * * 但是这个停止只是停止了 循环，并没有停止整个线程，通过抛出异常得方式可以使得整个线程真正得停下来 */ class Th7 extends Thread&#123; @Override public void run() &#123; for(int i=0;i&lt;10000;i++)&#123; if(Thread.interrupted())&#123; System.out.println(this.isInterrupted()); break; &#125; System.out.println(i); &#125; System.out.println("heihei,我还在运行喔"); &#125;&#125;public class Thread07 &#123; public static void main(String[] args) throws InterruptedException &#123; Th7 th7=new Th7(); th7.start(); Thread.sleep(50); //调整线程状态 th7.interrupt(); System.out.println(Thread.interrupted()); &#125;&#125; interruput 这个方法一般是配合着条件判断，或者抛异常来停止线程。 值得注意的是 ：当一个线程再阻塞，也就是再 sleep,wait,被join的时候，被interrupt是会抛出异常的。 线程的其他小点 suspend 和 resume 将线程挂起，resume使线程恢复，这个也不是安全的也不推荐。 yield ，这个就是放弃资源，重新排队，这个不退进入阻塞，而是直接重新开始排队。 线程的优先级： setPriority方法设置，1-10，默认5，注意优先级并不代表一定先执行。 守护线程：setDaemon可以设置某个线程为守护线程，守护亡则线程亡。 二、线程的同步都知道多线程处理同一份资源的时候，往往会出现线程非安全的问题。原因就是一个线程对一个资源进行了修改还没来得及保存，另一个线程也读取了这分资源进行了修改，只是后就会出现不同步的现象。 synchrnized同步方法123456789101112131415161718192021222324252627282930313233343536/** * 现在我们来加上锁试试 * 结果时不会又线程不安全问题的 * 等同于 同步了，一定要等a用完了这个方法，b才能去碰它 * */public class Thread13 &#123; private static int num; public synchronized static void addI(String uname) throws InterruptedException &#123; if(uname.equals("a"))&#123; num=100; System.out.println("a set over"); Thread.sleep(2000); &#125;else&#123; num=200; System.out.println("b set over"); &#125; System.out.println(uname+" num="+num); &#125; public static void main(String[] args)&#123; new Thread(()-&gt;&#123; try &#123; addI("a"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); new Thread(()-&gt;&#123; try &#123; addI("b"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; synchrnized同步块1234567891011121314151617181920212223242526272829303132333435363738/** * 同步代码块也是对象锁，当一个线程持有了一个对象的同步块锁，那么这个对象的所有上锁的方法都是同步的 * 不能被其他线程所访问，只有当这个线程结束，才会释放锁 * * 上面是锁this,我们也可以不锁this，而是锁另外一个对象，那么这个锁和整个类里面的其他锁就是异步的了 */public class Thread19 &#123; private String name; private String pwd; private void fun(String name ,String pwd) throws InterruptedException &#123; String anything=new String(); synchronized (anything)&#123; this.name=name; this.pwd=pwd; Thread.sleep(3000); System.out.println(Thread.currentThread().getName()+" name="+this.name+ " pwd="+this.pwd); &#125; &#125; public static void main(String[] args)&#123; Thread19 thread19=new Thread19(); new Thread(()-&gt;&#123; try &#123; thread19.fun("a","aaa"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); new Thread(()-&gt;&#123; try &#123; thread19.fun("b","bbb"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; volatile关键字轻基的锁，它所得是资源，也就是线程每次用到这个资源的时候都会区公共区看看这个资源是否改变，都会取读取公共部分的这个资源。这样就可以实现对一个线程的控制。 值得注意的是： 这个锁只对原子性=型操作有效。 关于死锁简单来说死锁就是互相持有对方需要的锁。。。 A线程持有A锁，在A线程里面需要调用上了B锁的资源。 B线程持有B锁，在B线程里需要调用上了A锁的资源，这个时候就很容易发生死锁， 嵌套锁是很容易导致死锁。 三、线程之间的通信wait 和 notify1234567891011121314151617181920212223242526272829303132333435363738/** * 这一部分是线程通信的学习： * 主要掌握的技术点： * 1、使用wait/notify实现线程之间的通信 * 2、生产者/消费者模式的实现 * 3、方法join的使用、 * 4、TreadLocal类额使用 *//** * wait使线程停止，停止必需要持有对象的锁，对象级别的锁， * 而notify/notifyall，刚好相反，它可以是线程恢复，但是它也需要对象锁，而且这把锁应该和它需要唤起的线程的对象 * 锁一致，方可唤起。 */public class Thread1 &#123; public static void main(String[] args) throws InterruptedException &#123; String lock=new String(); new Thread(()-&gt;&#123; synchronized (lock)&#123; System.out.println("第一个开始了"); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("第一个结束了"); &#125; &#125;).start(); Thread.sleep(2000); new Thread(()-&gt;&#123; synchronized (lock)&#123; System.out.println("第二个开始了"); lock.notify(); System.out.println("第二个结束了"); &#125; &#125;).start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 用wait/notify实现线程之间的通信 * 但结果是，另个一线程notify之后，wait线程并没有马上开始，而是等notify线程执行之后才执行 * 这是因为两个线程持有同一个锁，notify调用之后，可以让wait线程从阻塞状态到就绪状态。 * 但notify线程还没有释放同步锁，wait线程就只能同步等待 * 综上wait：让一个线程进入等待队列，并且释放同步锁，知道被另一个持有相同锁的线程调用notify才进入就绪状态 * notify:然同步锁相同的线程从阻塞状态进入就绪状态，但不会释放自己的同步锁。 */class MyList&#123; private static List list=new ArrayList(); public void add()&#123; list.add("anything"); &#125; public int size()&#123; return list.size(); &#125;&#125;public class Thread2 &#123; public static void main(String[] args)&#123; String lock=new String(); MyList list=new MyList(); new Thread(()-&gt;&#123; synchronized (lock)&#123; if(list.size()!=5)&#123; System.out.println("wait begin"); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("wait end"); &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; synchronized (lock)&#123; for(int i =0;i&lt;10;i++)&#123; list.add(); if(i==5)&#123; System.out.println("发出通知"); lock.notify(); &#125; System.out.println("添加了"+(i+1)+"个元素"); &#125; &#125; &#125;).start(); &#125;&#125; 稍微总结：wait时线程进入阻塞、并且释放锁，当线程被notify时，并不能马上开始，需要等notufy线程执行完毕释放了锁才能拿到锁，开始执行。这两个方法都是需要对象锁的！！！ 同步代码块，就是锁的范围缩小，我们应该让公共的变量被赋值的代码进行加锁，应该在线程结束之际在对其进行赋值,用私有变量保存小操作，可是这样连私有 线程通道流12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152** * 在javaz中有各种各样的io流操作，关于线程的io有以下几种 * PipedInpuStream PipedOutputStream * out.connect(in); 来连接两个流实现两个线程之间的交流 * PipedReader PepedWriter * 字符流操作大同小异，就是读出的时候不用再将字符变成字节，读取的时候创建一个字符数组或者stringbuild */public class Thread6 &#123; private void writeMthod(PipedOutputStream out) throws IOException &#123; System.out.println("write:"); for(int i=0;i&lt;300;i++)&#123; String outDate=""+(i+1); out.write(outDate.getBytes()); System.out.print(outDate); &#125; System.out.println(); out.close(); &#125; private void readMthod(PipedInputStream in) throws IOException &#123; System.out.println("read:"); byte[] bytes=new byte[20]; int lengh=in.read(bytes); while(lengh!=-1)&#123; String inDate=new String(bytes,0,lengh); System.out.print(inDate); lengh=in.read(bytes); &#125; System.out.println(); in.close(); &#125; public static void main(String[] args) throws IOException, InterruptedException &#123; Thread6 thread6=new Thread6(); PipedOutputStream out=new PipedOutputStream(); PipedInputStream in=new PipedInputStream(); out.connect(in); new Thread(()-&gt;&#123; try &#123; thread6.readMthod(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); Thread.sleep(200); new Thread(()-&gt;&#123; try &#123; thread6.writeMthod(out); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; join 开始体验join实现线程之间的通信了。 在一个线程中 调用另一个线程的join方法，那么本线程将会进入阻塞状态，直到join的线程结束了 才会继续执行 在阻塞中的线程被调用 interrupt方法进行打断，都会抛出异常 join也有像wait(long)一样的方法，jion(long），而且底层就是用wait(long)实现的，所有也会释放锁 join(long)和wai(long)t不一样的是，join设置的时间到了也还要那个线程结束了才能唤起。但wait时间到了没有被notify也会被唤起 而且join是线程的方法，wait必要线程同步锁锁的对象！ sleep，是不释放锁的，一个线程在sleep的时候是始终持有着锁，其他线程无法访问 ThreadLocal 和 InheritableThreadLocal1、体验ThreadLocal：它相当于每个线程都个公共部分的变量设置一个私有的箱子，装着私有的内容。 简单来讲就是公共变量对每个线程都有自己私有的值。 它是一种泛型容器–，放在定义公共变量的前面. 它的底层是一个map,这个map会存放在所有的线程，然后每次去存取的时候，都会先找到当前线程。 如果从未存过内容，调用get会返回null。 2、没有存放get也可以不是null,方法是定义一个新的类继承ThreadLocal 当然要去复写initialValue方法，它就是定义了默认没有set的时候get出来的值。 当然这也继承出来的类，也是符合每个线程对公共变量可以有自己私有的值。 3、这里体验：InheritableThreadLocal的使用 名字真的是贼长…. 作用：就是让子线程可以从父线程中取值。。。 我觉得这里要明白一个东西就是 子父线程，这里不是线程之间的继承，而是父线中开创了子线程。 而且子线程也可以对这个值进行修改，但是这个修改不会对父线程值造成影响。 通知这种继承也实现了线程之间的通信 写在最后 char a =0 ; 这样a什么都没有的，null都不是 getIndexOf(String1,String2) 可以判断第一个字符串是否包含另一个字符串。包含放回起始位置，不包含返回-1。 123456789101112131415public static void main(String[] args)&#123; String a="12312314"; int abs=0; int[] index =new int[128]; /** * 动态规划：计算当前能到达当前位置的最长字符串，要有个头 * 这个头就是i，头的选择是从本来的i和当前字符前一次出现的下一个位置。得到头 */ for(int i=0,j=0;j&lt;a.length();j++)&#123; i=Math.max(i,index[a.charAt(j)]); abs=Math.max(abs,j-i+1); index[a.charAt(j)]=j+1; //这里是记录下 下一个位置，从j以后没有j位置上这个字符 &#125; System.out.println(abs); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about me]]></title>
    <url>%2F2019%2F04%2F12%2Fabout-me%2F</url>
    <content type="text"><![CDATA[今天是2019.4.13–我念大三，从今天起记录我的生活。 2019-4-15 阴今天继续学习了JVM，这书看得非常的难受，先看到着吧，这本书以后再翻。这个月也不准备在学很多新知识了，准备做一个阶段性的复习，回顾整理。 2019-4-14 多云我已经写了两篇文章啦，还是很开心的。我在过着我喜欢的日子，不再有过去两年那种迷茫。 2019-4-12 雨初次尝试搭建一个博客，作为一个没什么审美的boy，照着文档七七八八的把功能补齐了，先凑合着用吧。我的其实是想记录下自己的所学，每天都能记录下来一些东西。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>置顶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F12%2FJVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近学习Java虚拟机，看的是深入理解Java虚拟机，整本书内容还还是非常的多的，而且有一些知识似乎还太适合我…..水平不够。然后准备做点读书笔记和一些自己的思考。 JVM学习笔记（一） 我主要准备学习的有一下三部分： JVM虚拟内存和GC Java类的J加载机制 代码的优化） 本文主要总结一下第一部分，内存模型和垃圾回收机制。Java内存模型 先来看看一张JVM内存模型图 1. 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 各个线程独有，每个线程都有一个。内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。 2. java虚拟机栈与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈存放的是局部变量表、一些方法体内的东西。在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。 3. 本地方法栈这个和java虚拟机栈差不多，只不过它存放的是本地的方法，也就是native的方法。 4. Java堆堆占了很大一块内存它的作用：存放着所有的事例话对象，这里也是垃圾回收的主要目标了。后面讲垃圾回收在来自己看看。 5. 方法区方法区其实是在类加载的时一些类的信息，静态变量，常量，以及一些编译后的代码等数据。 6. 运行时的常量池常量池是方法区的一部分，常量池存放着编期生成的各种字面变量。这里有意思的是一个字符串常量池，和intern()方法： intern方法，是将堆里面的字符串对象试着放入字符转常量池，何为尝试？是这的，字符串放入常量池时，会先看看常量池中时候有这个字符串，如果有，则直接返回，我还是堆里面的我；如果没有，就回在常量池中创建这个字符串，然后返回常量池中这个字符串的引用，那么现在就不再时堆里面的那个我了，我就是指向常量池的那个我。 String a =” ads” ，这样去构造一个字符串对象，它首先会去看看常量池中是否有这个字符串，如果I有，就直接返回常量池的字符串引用。如果没有它就会在常量池中创建这个字符串然后然后返回。也就是是说，这样构造字符串一定是指向常量池的。 String a=new String(“sas”)。这样创建的话就是在堆里面的事例对象了。 ==，成立的前提是要对象一样（常量除外） 12345678910111213141516171819202122232425 public static void main(String[] args)&#123; String a =new String("1")+new String("1"); a.intern(); String b="11"; String c=new String("1")+new String("1"); c.intern(); System.out.println(a==b); //true 都是常量池中的 “11” System.out.println(a==c); //false c.intern时，常量池中已经有了“11”。所有c还是堆里的对象 System.out.println(b==c); //flase a==b,a!=c.自然 b!=c &#125;public static void main(String[] args)&#123; String b="11"; String a =new String("1")+new String("1"); a.intern(); System.out.println(a==b); //false 一样，先b就让常量池中有了“11”，a就intern不进去了 &#125;public static void main(String[] args)&#123; String a =new String("ja")+new String("va"); a.intern(); String b="java"; System.out.println(a==b); //这个也是false,因为常量池中本来就有"java".....我也不知道问什么本来就有 &#125; 7. 直接内存 直接内存其实也叫堆外内存。学习NIO的时候有了解一点，NIO在创建buffer时，就有两种allocate选择，其中有一种就是直接内存，数据是直接与底层的磁盘打交道。。。。。 Java垃圾回收机制一、判断是否可以回收的两个算法1、引用计数法算法介绍：简单来说一个对象被引用我就给他加一，失去引用就减一，以这个数来判断时候可以回收 缺点：无法解决对象之间的相互引用问题，所有jvm们基本都不是这么干的 2、可达性分析算法介绍：GC Roots，着就像一个根，所有的对象只要能和它扯上关系的就可以不被回收，也就是GC Root可以到达这些对象，如果GC Root不可达了，也就说明可以回收了 这个算法是现在用来判断是否可以回收的算法 在简单的说说引用：引用分四种：强引用、软引用、弱引用、虚引用。。。强度依次降低 分级作用：可以让垃圾回收有了分情况处理的能力，内存比较悠闲可以先不回收那些低级引用，如果内存紧张那么也知道应该先回收哪些。 二、垃圾回收算法1、标记-清除算法介绍：先标记，然后差不多了 就统一回收了 缺点： 效率不高 容易产生很多内存碎片，及其不集中，这样使得如果有大内存对象就不好处理了 2、复制算法介绍：把堆分成两份，一次只操作一遍，当这边的内存满了就将不要清楚的对象复制到另一边，然后统一清楚。 特点： 解决了标记-清楚的内存碎片问题 可以有一半的内存不被使用，效率可想而知，浪费啊！！ 3、标记-整理算法介绍：在标记-清除上做了一些改变，前面标记差不多，只是到了最后不是直接清除，而是将存活的对象移动到一端，其他的要清除的就清除掉 4、分代回收算法介绍：分代回收其实是一种思想，它肯定是要配合着前面的算法时候用，就是将堆里面的对象分为新生代和老年代 新生代：其实是马上要死了的。。。。别看它新， 老年代：这才是老不死的家伙，经常需要然后就很少被清除 总结一下：就是现在的虚拟机基本上是配合着使用的，老年代用标记-清除，新生代用复制算法三、主要的垃圾回收器1、串行：垃圾回收器 (Serial Garbage Collector)(1)串行垃圾回收器在进行垃圾回收时，它会持有所有应用程序的线程，冻结所有应用程序线程，使用单个垃圾回收线程来进行垃圾回收工作。 串行垃圾回收器是为单线程环境而设计的，如果你的程序不需要多线程，启动串行垃圾回收。 (2)串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）使用方法：-XX:+UseSerialGC 串联收集 Ps：在jdk client模式，不指定VM参数，默认是串行垃圾回收器 2、串行：ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩使用方法：-XX:+UseParNewGC ParNew收集器 -XX:ParallelGCThreads 限制线程数量 3、并行：Parallel收集器Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩使用方法：-XX:+UseParallelGC 使用Parallel收集器+ 老年代串行 4、并行：Parallel Old 收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供使用方法： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 5、并发标记扫描CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 java官方介绍：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：初始标记（CMS initial mark）并发标记（CMS concurrent mark）重新标记（CMS remark）并发清除（CMS concurrent sweep）其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew） 优点:并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 6、G1收集器G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：(1). 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。(2). 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。收集步骤：1)、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)2)、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。3)、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。4)、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。5)、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。6)、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 唯一和串行垃圾回收器不同的是，并行垃圾回收器是使用多线程来进行垃圾回收工作的。 这些垃圾回收器应该只要有个印象吧，记不住=———-]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
