<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[about me]]></title>
    <url>%2F2019%2F04%2F12%2Fabout-me%2F</url>
    <content type="text"><![CDATA[今天是2019.4.13–我念大三，从今天起记录我的生活 初次尝试搭建一个博客，作为一个没什么审美的boy，照着文档七七八八的把功能补齐了，先凑合着用吧。我的其实是想记录下自己的所学，每天都能记录下来一些东西。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>置顶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F12%2FJVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JVM学习笔记（一） 最近学习Java虚拟机，看的是深入理解Java虚拟机，整本书内容还还是非常的多的，而且有一些知识似乎还太适合我…..水平不够。然后准备做点读书笔记和一些自己的思考。 我主要准备学习的有一下三部分： JVM虚拟内存和GC Java类的J加载机制 代码的优化） 本文主要总结一下第一部分，内存模型和垃圾回收机制。Java内存模型 先来看看一张JVM内存模型图 1. 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 各个线程独有，每个线程都有一个。内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。 2. java虚拟机栈与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈存放的是局部变量表、一些方法体内的东西。在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。 3. 本地方法栈这个和java虚拟机栈差不多，只不过它存放的是本地的方法，也就是native的方法。 4. Java堆堆占了很大一块内存它的作用：存放着所有的事例话对象，这里也是垃圾回收的主要目标了。后面讲垃圾回收在来自己看看。 5. 方法区方法区其实是在类加载的时一些类的信息，静态变量，常量，以及一些编译后的代码等数据。 6. 运行时的常量池常量池是方法区的一部分，常量池存放着编期生成的各种字面变量。这里有意思的是一个字符串常量池，和intern()方法： intern方法，是将堆里面的字符串对象试着放入字符转常量池，何为尝试？是这的，字符串放入常量池时，会先看看常量池中时候有这个字符串，如果有，则直接返回，我还是堆里面的我；如果没有，就回在常量池中创建这个字符串，然后返回常量池中这个字符串的引用，那么现在就不再时堆里面的那个我了，我就是指向常量池的那个我。 String a =” ads” ，这样去构造一个字符串对象，它首先会去看看常量池中是否有这个字符串，如果I有，就直接返回常量池的字符串引用。如果没有它就会在常量池中创建这个字符串然后然后返回。也就是是说，这样构造字符串一定是指向常量池的。 String a=new String(“sas”)。这样创建的话就是在堆里面的事例对象了。 ==，成立的前提是要对象一样（常量除外） 12345678910111213141516171819202122232425 public static void main(String[] args)&#123; String a =new String("1")+new String("1"); a.intern(); String b="11"; String c=new String("1")+new String("1"); c.intern(); System.out.println(a==b); //true 都是常量池中的 “11” System.out.println(a==c); //false c.intern时，常量池中已经有了“11”。所有c还是堆里的对象 System.out.println(b==c); //flase a==b,a!=c.自然 b!=c &#125;public static void main(String[] args)&#123; String b="11"; String a =new String("1")+new String("1"); a.intern(); System.out.println(a==b); //false 一样，先b就让常量池中有了“11”，a就intern不进去了 &#125;public static void main(String[] args)&#123; String a =new String("ja")+new String("va"); a.intern(); String b="java"; System.out.println(a==b); //这个也是false,因为常量池中本来就有"java".....我也不知道问什么本来就有 &#125; 7. 直接内存 直接内存其实也叫堆外内存。学习NIO的时候有了解一点，NIO在创建buffer时，就有两种allocate选择，其中有一种就是直接内存，数据是直接与底层的磁盘打交道。。。。。 Java垃圾回收机制一、判断是否可以回收的两个算法1、引用计数法算法介绍：简单来说一个对象被引用我就给他加一，失去引用就减一，以这个数来判断时候可以回收 缺点：无法解决对象之间的相互引用问题，所有jvm们基本都不是这么干的 2、可达性分析算法介绍：GC Roots，着就像一个根，所有的对象只要能和它扯上关系的就可以不被回收，也就是GC Root可以到达这些对象，如果GC Root不可达了，也就说明可以回收了 这个算法是现在用来判断是否可以回收的算法 在简单的说说引用：引用分四种：强引用、软引用、弱引用、虚引用。。。强度依次降低 分级作用：可以让垃圾回收有了分情况处理的能力，内存比较悠闲可以先不回收那些低级引用，如果内存紧张那么也知道应该先回收哪些。 二、垃圾回收算法1、标记-清除算法介绍：先标记，然后差不多了 就统一回收了 缺点： 效率不高 容易产生很多内存碎片，及其不集中，这样使得如果有大内存对象就不好处理了 2、复制算法介绍：把堆分成两份，一次只操作一遍，当这边的内存满了就将不要清楚的对象复制到另一边，然后统一清楚。 特点： 解决了标记-清楚的内存碎片问题 可以有一半的内存不被使用，效率可想而知，浪费啊！！ 3、标记-整理算法介绍：在标记-清除上做了一些改变，前面标记差不多，只是到了最后不是直接清除，而是将存活的对象移动到一端，其他的要清除的就清除掉 4、分代回收算法介绍：分代回收其实是一种思想，它肯定是要配合着前面的算法时候用，就是将堆里面的对象分为新生代和老年代 新生代：其实是马上要死了的。。。。别看它新， 老年代：这才是老不死的家伙，经常需要然后就很少被清除 总结一下：就是现在的虚拟机基本上是配合着使用的，老年代用标记-清除，新生代用复制算法三、主要的垃圾回收器1、串行：垃圾回收器 (Serial Garbage Collector)(1)串行垃圾回收器在进行垃圾回收时，它会持有所有应用程序的线程，冻结所有应用程序线程，使用单个垃圾回收线程来进行垃圾回收工作。 串行垃圾回收器是为单线程环境而设计的，如果你的程序不需要多线程，启动串行垃圾回收。 (2)串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）使用方法：-XX:+UseSerialGC 串联收集 Ps：在jdk client模式，不指定VM参数，默认是串行垃圾回收器 2、串行：ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩使用方法：-XX:+UseParNewGC ParNew收集器 -XX:ParallelGCThreads 限制线程数量 3、并行：Parallel收集器Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩使用方法：-XX:+UseParallelGC 使用Parallel收集器+ 老年代串行 4、并行：Parallel Old 收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供使用方法： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 5、并发标记扫描CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 java官方介绍：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：初始标记（CMS initial mark）并发标记（CMS concurrent mark）重新标记（CMS remark）并发清除（CMS concurrent sweep）其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew） 优点:并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 6、G1收集器G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：(1). 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。(2). 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。收集步骤：1)、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)2)、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。3)、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。4)、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。5)、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。6)、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 唯一和串行垃圾回收器不同的是，并行垃圾回收器是使用多线程来进行垃圾回收工作的。 这些垃圾回收器应该只要有个印象吧，记不住=———-]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
