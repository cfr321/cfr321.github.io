<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java多线程学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F14%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java多线程编程核心技术也看了大半了，感觉时候做点总结了，这本书看着还是比较轻松愉快的，推荐推荐。书本用的了很多事例去讲解多线程的种种API，作为多线程学习还是很不错的。 Java多线程开山篇我就不一点一点总结了，毕竟别人总结的已经很好了，需要总体复习的时候看看别人总结的就挺不错了，学习时间够写博客时间自然得zip一下。 Thread 主要API一、体验多线程继承Thread类，实现Runnable接口，一般推荐后面的方法，因为继承只能有一个嘛。 1234567891011121314151617/** * 体验线程 * 线程的调用不是跟随程序书写的先后来决定的 */class Tread extends Thread&#123; @Override public void run() &#123; System.out.println("我被调用了"); &#125;&#125;public class Thread01 &#123; public static void main(String[] args)&#123; Tread s=new Tread(); s.start(); System.out.println("主线程被调用了"); &#125;&#125; 二、Thread主要的方法基本方法 currentThread() 获取当前线程 isAlive 判断线程时候已经结束 sleep 让线程进入阻塞状态，并且是规定时间的 getId 获得线程的ID，这相当于给每个线程编号，每个线程都有一个自己的ID 线程的停止 1234567891011121314151617181920212223242526272829303132333435363738/** * 线程的停止： * 1、run方法结束线程自然停止 * 2、调用stop方法，强行停止线程，但这是不安全的，不建议使用 * 3、调用interruput，这个方法并不是马上的停止线程，而是基于线程一个 interruput的值得改变 * 作为一个标记，通过这个boolen值得改变，进行if判断来终止循环，从而终止线程。 * interruputed是当前线程又类调用得，它得调用会使得true变成false,而且测试来看 * 调用interruput方法，先interruputed变成true，后isInterruputed变为true， * 因为我多次测试，用interruputed方法作为判断条件，打印得isInterruputed得结果依然还是false * Interruputed方法得调用，不会改变自身得值 * * 但是这个停止只是停止了 循环，并没有停止整个线程，通过抛出异常得方式可以使得整个线程真正得停下来 */ class Th7 extends Thread&#123; @Override public void run() &#123; for(int i=0;i&lt;10000;i++)&#123; if(Thread.interrupted())&#123; System.out.println(this.isInterrupted()); break; &#125; System.out.println(i); &#125; System.out.println("heihei,我还在运行喔"); &#125;&#125;public class Thread07 &#123; public static void main(String[] args) throws InterruptedException &#123; Th7 th7=new Th7(); th7.start(); Thread.sleep(50); //调整线程状态 th7.interrupt(); System.out.println(Thread.interrupted()); &#125;&#125; interruput 这个方法一般是配合着条件判断，或者抛异常来停止线程。 值得注意的是 ：当一个线程再阻塞，也就是再 sleep,wait,被join的时候，被interrupt是会抛出异常的。 线程的其他小点 suspend 和 resume 将线程挂起，resume使线程恢复，这个也不是安全的也不推荐。 yield ，这个就是放弃资源，重新排队，这个不退进入阻塞，而是直接重新开始排队。 线程的优先级： setPriority方法设置，1-10，默认5，注意优先级并不代表一定先执行。 守护线程：setDaemon可以设置某个线程为守护线程，守护亡则线程亡。 二、线程的同步都知道多线程处理同一份资源的时候，往往会出现线程非安全的问题。原因就是一个线程对一个资源进行了修改还没来得及保存，另一个线程也读取了这分资源进行了修改，只是后就会出现不同步的现象。 synchrnized同步方法123456789101112131415161718192021222324252627282930313233343536/** * 现在我们来加上锁试试 * 结果时不会又线程不安全问题的 * 等同于 同步了，一定要等a用完了这个方法，b才能去碰它 * */public class Thread13 &#123; private static int num; public synchronized static void addI(String uname) throws InterruptedException &#123; if(uname.equals("a"))&#123; num=100; System.out.println("a set over"); Thread.sleep(2000); &#125;else&#123; num=200; System.out.println("b set over"); &#125; System.out.println(uname+" num="+num); &#125; public static void main(String[] args)&#123; new Thread(()-&gt;&#123; try &#123; addI("a"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); new Thread(()-&gt;&#123; try &#123; addI("b"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; synchrnized同步块1234567891011121314151617181920212223242526272829303132333435363738/** * 同步代码块也是对象锁，当一个线程持有了一个对象的同步块锁，那么这个对象的所有上锁的方法都是同步的 * 不能被其他线程所访问，只有当这个线程结束，才会释放锁 * * 上面是锁this,我们也可以不锁this，而是锁另外一个对象，那么这个锁和整个类里面的其他锁就是异步的了 */public class Thread19 &#123; private String name; private String pwd; private void fun(String name ,String pwd) throws InterruptedException &#123; String anything=new String(); synchronized (anything)&#123; this.name=name; this.pwd=pwd; Thread.sleep(3000); System.out.println(Thread.currentThread().getName()+" name="+this.name+ " pwd="+this.pwd); &#125; &#125; public static void main(String[] args)&#123; Thread19 thread19=new Thread19(); new Thread(()-&gt;&#123; try &#123; thread19.fun("a","aaa"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); new Thread(()-&gt;&#123; try &#123; thread19.fun("b","bbb"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; volatile关键字轻基的锁，它所得是资源，也就是线程每次用到这个资源的时候都会区公共区看看这个资源是否改变，都会取读取公共部分的这个资源。这样就可以实现对一个线程的控制。 值得注意的是： 这个锁只对原子性=型操作有效。 关于死锁简单来说死锁就是互相持有对方需要的锁。。。 A线程持有A锁，在A线程里面需要调用上了B锁的资源。 B线程持有B锁，在B线程里需要调用上了A锁的资源，这个时候就很容易发生死锁， 嵌套锁是很容易导致死锁。 三、线程之间的通信wait 和 notify1234567891011121314151617181920212223242526272829303132333435363738/** * 这一部分是线程通信的学习： * 主要掌握的技术点： * 1、使用wait/notify实现线程之间的通信 * 2、生产者/消费者模式的实现 * 3、方法join的使用、 * 4、TreadLocal类额使用 *//** * wait使线程停止，停止必需要持有对象的锁，对象级别的锁， * 而notify/notifyall，刚好相反，它可以是线程恢复，但是它也需要对象锁，而且这把锁应该和它需要唤起的线程的对象 * 锁一致，方可唤起。 */public class Thread1 &#123; public static void main(String[] args) throws InterruptedException &#123; String lock=new String(); new Thread(()-&gt;&#123; synchronized (lock)&#123; System.out.println("第一个开始了"); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("第一个结束了"); &#125; &#125;).start(); Thread.sleep(2000); new Thread(()-&gt;&#123; synchronized (lock)&#123; System.out.println("第二个开始了"); lock.notify(); System.out.println("第二个结束了"); &#125; &#125;).start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 用wait/notify实现线程之间的通信 * 但结果是，另个一线程notify之后，wait线程并没有马上开始，而是等notify线程执行之后才执行 * 这是因为两个线程持有同一个锁，notify调用之后，可以让wait线程从阻塞状态到就绪状态。 * 但notify线程还没有释放同步锁，wait线程就只能同步等待 * 综上wait：让一个线程进入等待队列，并且释放同步锁，知道被另一个持有相同锁的线程调用notify才进入就绪状态 * notify:然同步锁相同的线程从阻塞状态进入就绪状态，但不会释放自己的同步锁。 */class MyList&#123; private static List list=new ArrayList(); public void add()&#123; list.add("anything"); &#125; public int size()&#123; return list.size(); &#125;&#125;public class Thread2 &#123; public static void main(String[] args)&#123; String lock=new String(); MyList list=new MyList(); new Thread(()-&gt;&#123; synchronized (lock)&#123; if(list.size()!=5)&#123; System.out.println("wait begin"); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("wait end"); &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; synchronized (lock)&#123; for(int i =0;i&lt;10;i++)&#123; list.add(); if(i==5)&#123; System.out.println("发出通知"); lock.notify(); &#125; System.out.println("添加了"+(i+1)+"个元素"); &#125; &#125; &#125;).start(); &#125;&#125; 稍微总结：wait时线程进入阻塞、并且释放锁，当线程被notify时，并不能马上开始，需要等notufy线程执行完毕释放了锁才能拿到锁，开始执行。这两个方法都是需要对象锁的！！！ 同步代码块，就是锁的范围缩小，我们应该让公共的变量被赋值的代码进行加锁，应该在线程结束之际在对其进行赋值,用私有变量保存小操作，可是这样连私有 线程通道流12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152** * 在javaz中有各种各样的io流操作，关于线程的io有以下几种 * PipedInpuStream PipedOutputStream * out.connect(in); 来连接两个流实现两个线程之间的交流 * PipedReader PepedWriter * 字符流操作大同小异，就是读出的时候不用再将字符变成字节，读取的时候创建一个字符数组或者stringbuild */public class Thread6 &#123; private void writeMthod(PipedOutputStream out) throws IOException &#123; System.out.println("write:"); for(int i=0;i&lt;300;i++)&#123; String outDate=""+(i+1); out.write(outDate.getBytes()); System.out.print(outDate); &#125; System.out.println(); out.close(); &#125; private void readMthod(PipedInputStream in) throws IOException &#123; System.out.println("read:"); byte[] bytes=new byte[20]; int lengh=in.read(bytes); while(lengh!=-1)&#123; String inDate=new String(bytes,0,lengh); System.out.print(inDate); lengh=in.read(bytes); &#125; System.out.println(); in.close(); &#125; public static void main(String[] args) throws IOException, InterruptedException &#123; Thread6 thread6=new Thread6(); PipedOutputStream out=new PipedOutputStream(); PipedInputStream in=new PipedInputStream(); out.connect(in); new Thread(()-&gt;&#123; try &#123; thread6.readMthod(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); Thread.sleep(200); new Thread(()-&gt;&#123; try &#123; thread6.writeMthod(out); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; join 开始体验join实现线程之间的通信了。 在一个线程中 调用另一个线程的join方法，那么本线程将会进入阻塞状态，直到join的线程结束了 才会继续执行 在阻塞中的线程被调用 interrupt方法进行打断，都会抛出异常 join也有像wait(long)一样的方法，jion(long），而且底层就是用wait(long)实现的，所有也会释放锁 join(long)和wai(long)t不一样的是，join设置的时间到了也还要那个线程结束了才能唤起。但wait时间到了没有被notify也会被唤起 而且join是线程的方法，wait必要线程同步锁锁的对象！ sleep，是不释放锁的，一个线程在sleep的时候是始终持有着锁，其他线程无法访问 ThreadLocal 和 InheritableThreadLocal1、体验ThreadLocal：它相当于每个线程都个公共部分的变量设置一个私有的箱子，装着私有的内容。 简单来讲就是公共变量对每个线程都有自己私有的值。 它是一种泛型容器–，放在定义公共变量的前面. 它的底层是一个map,这个map会存放在所有的线程，然后每次去存取的时候，都会先找到当前线程。 如果从未存过内容，调用get会返回null。 2、没有存放get也可以不是null,方法是定义一个新的类继承ThreadLocal 当然要去复写initialValue方法，它就是定义了默认没有set的时候get出来的值。 当然这也继承出来的类，也是符合每个线程对公共变量可以有自己私有的值。 3、这里体验：InheritableThreadLocal的使用 名字真的是贼长…. 作用：就是让子线程可以从父线程中取值。。。 我觉得这里要明白一个东西就是 子父线程，这里不是线程之间的继承，而是父线中开创了子线程。 而且子线程也可以对这个值进行修改，但是这个修改不会对父线程值造成影响。 通知这种继承也实现了线程之间的通信 写在最后 char a =0 ; 这样a什么都没有的，null都不是 getIndexOf(String1,String2) 可以判断第一个字符串是否包含另一个字符串。包含放回起始位置，不包含返回-1。 123456789101112131415public static void main(String[] args)&#123; String a="12312314"; int abs=0; int[] index =new int[128]; /** * 动态规划：计算当前能到达当前位置的最长字符串，要有个头 * 这个头就是i，头的选择是从本来的i和当前字符前一次出现的下一个位置。得到头 */ for(int i=0,j=0;j&lt;a.length();j++)&#123; i=Math.max(i,index[a.charAt(j)]); abs=Math.max(abs,j-i+1); index[a.charAt(j)]=j+1; //这里是记录下 下一个位置，从j以后没有j位置上这个字符 &#125; System.out.println(abs); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about me]]></title>
    <url>%2F2019%2F04%2F12%2Fabout-me%2F</url>
    <content type="text"><![CDATA[今天是2019.4.13–我念大三，从今天起记录我的生活。 2019-4-14 多云我已经写了两篇文章啦，还是很开心的。我在过着我喜欢的日子，不再有过去两年那种迷茫。 2019-4-12 雨初次尝试搭建一个博客，作为一个没什么审美的boy，照着文档七七八八的把功能补齐了，先凑合着用吧。我的其实是想记录下自己的所学，每天都能记录下来一些东西。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>置顶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F12%2FJVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近学习Java虚拟机，看的是深入理解Java虚拟机，整本书内容还还是非常的多的，而且有一些知识似乎还太适合我…..水平不够。然后准备做点读书笔记和一些自己的思考。 JVM学习笔记（一） 我主要准备学习的有一下三部分： JVM虚拟内存和GC Java类的J加载机制 代码的优化） 本文主要总结一下第一部分，内存模型和垃圾回收机制。Java内存模型 先来看看一张JVM内存模型图 1. 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 各个线程独有，每个线程都有一个。内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。 2. java虚拟机栈与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈存放的是局部变量表、一些方法体内的东西。在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。 3. 本地方法栈这个和java虚拟机栈差不多，只不过它存放的是本地的方法，也就是native的方法。 4. Java堆堆占了很大一块内存它的作用：存放着所有的事例话对象，这里也是垃圾回收的主要目标了。后面讲垃圾回收在来自己看看。 5. 方法区方法区其实是在类加载的时一些类的信息，静态变量，常量，以及一些编译后的代码等数据。 6. 运行时的常量池常量池是方法区的一部分，常量池存放着编期生成的各种字面变量。这里有意思的是一个字符串常量池，和intern()方法： intern方法，是将堆里面的字符串对象试着放入字符转常量池，何为尝试？是这的，字符串放入常量池时，会先看看常量池中时候有这个字符串，如果有，则直接返回，我还是堆里面的我；如果没有，就回在常量池中创建这个字符串，然后返回常量池中这个字符串的引用，那么现在就不再时堆里面的那个我了，我就是指向常量池的那个我。 String a =” ads” ，这样去构造一个字符串对象，它首先会去看看常量池中是否有这个字符串，如果I有，就直接返回常量池的字符串引用。如果没有它就会在常量池中创建这个字符串然后然后返回。也就是是说，这样构造字符串一定是指向常量池的。 String a=new String(“sas”)。这样创建的话就是在堆里面的事例对象了。 ==，成立的前提是要对象一样（常量除外） 12345678910111213141516171819202122232425 public static void main(String[] args)&#123; String a =new String("1")+new String("1"); a.intern(); String b="11"; String c=new String("1")+new String("1"); c.intern(); System.out.println(a==b); //true 都是常量池中的 “11” System.out.println(a==c); //false c.intern时，常量池中已经有了“11”。所有c还是堆里的对象 System.out.println(b==c); //flase a==b,a!=c.自然 b!=c &#125;public static void main(String[] args)&#123; String b="11"; String a =new String("1")+new String("1"); a.intern(); System.out.println(a==b); //false 一样，先b就让常量池中有了“11”，a就intern不进去了 &#125;public static void main(String[] args)&#123; String a =new String("ja")+new String("va"); a.intern(); String b="java"; System.out.println(a==b); //这个也是false,因为常量池中本来就有"java".....我也不知道问什么本来就有 &#125; 7. 直接内存 直接内存其实也叫堆外内存。学习NIO的时候有了解一点，NIO在创建buffer时，就有两种allocate选择，其中有一种就是直接内存，数据是直接与底层的磁盘打交道。。。。。 Java垃圾回收机制一、判断是否可以回收的两个算法1、引用计数法算法介绍：简单来说一个对象被引用我就给他加一，失去引用就减一，以这个数来判断时候可以回收 缺点：无法解决对象之间的相互引用问题，所有jvm们基本都不是这么干的 2、可达性分析算法介绍：GC Roots，着就像一个根，所有的对象只要能和它扯上关系的就可以不被回收，也就是GC Root可以到达这些对象，如果GC Root不可达了，也就说明可以回收了 这个算法是现在用来判断是否可以回收的算法 在简单的说说引用：引用分四种：强引用、软引用、弱引用、虚引用。。。强度依次降低 分级作用：可以让垃圾回收有了分情况处理的能力，内存比较悠闲可以先不回收那些低级引用，如果内存紧张那么也知道应该先回收哪些。 二、垃圾回收算法1、标记-清除算法介绍：先标记，然后差不多了 就统一回收了 缺点： 效率不高 容易产生很多内存碎片，及其不集中，这样使得如果有大内存对象就不好处理了 2、复制算法介绍：把堆分成两份，一次只操作一遍，当这边的内存满了就将不要清楚的对象复制到另一边，然后统一清楚。 特点： 解决了标记-清楚的内存碎片问题 可以有一半的内存不被使用，效率可想而知，浪费啊！！ 3、标记-整理算法介绍：在标记-清除上做了一些改变，前面标记差不多，只是到了最后不是直接清除，而是将存活的对象移动到一端，其他的要清除的就清除掉 4、分代回收算法介绍：分代回收其实是一种思想，它肯定是要配合着前面的算法时候用，就是将堆里面的对象分为新生代和老年代 新生代：其实是马上要死了的。。。。别看它新， 老年代：这才是老不死的家伙，经常需要然后就很少被清除 总结一下：就是现在的虚拟机基本上是配合着使用的，老年代用标记-清除，新生代用复制算法三、主要的垃圾回收器1、串行：垃圾回收器 (Serial Garbage Collector)(1)串行垃圾回收器在进行垃圾回收时，它会持有所有应用程序的线程，冻结所有应用程序线程，使用单个垃圾回收线程来进行垃圾回收工作。 串行垃圾回收器是为单线程环境而设计的，如果你的程序不需要多线程，启动串行垃圾回收。 (2)串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）使用方法：-XX:+UseSerialGC 串联收集 Ps：在jdk client模式，不指定VM参数，默认是串行垃圾回收器 2、串行：ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩使用方法：-XX:+UseParNewGC ParNew收集器 -XX:ParallelGCThreads 限制线程数量 3、并行：Parallel收集器Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩使用方法：-XX:+UseParallelGC 使用Parallel收集器+ 老年代串行 4、并行：Parallel Old 收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供使用方法： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 5、并发标记扫描CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 java官方介绍：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：初始标记（CMS initial mark）并发标记（CMS concurrent mark）重新标记（CMS remark）并发清除（CMS concurrent sweep）其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew） 优点:并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 6、G1收集器G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：(1). 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。(2). 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。收集步骤：1)、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)2)、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。3)、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。4)、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。5)、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。6)、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 唯一和串行垃圾回收器不同的是，并行垃圾回收器是使用多线程来进行垃圾回收工作的。 这些垃圾回收器应该只要有个印象吧，记不住=———-]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
